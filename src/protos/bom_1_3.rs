// This file is generated by rust-protobuf 2.24.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `bom-1.3.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_24_1;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AttachedText {
    // message fields
    pub value: ::std::string::String,
    // message oneof groups
    pub _content_type: ::std::option::Option<AttachedText_oneof__content_type>,
    pub _encoding: ::std::option::Option<AttachedText_oneof__encoding>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttachedText {
    fn default() -> &'a AttachedText {
        <AttachedText as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum AttachedText_oneof__content_type {
    content_type(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum AttachedText_oneof__encoding {
    encoding(::std::string::String),
}

impl AttachedText {
    pub fn new() -> AttachedText {
        ::std::default::Default::default()
    }

    // string content_type = 1;


    pub fn get_content_type(&self) -> &str {
        match self._content_type {
            ::std::option::Option::Some(AttachedText_oneof__content_type::content_type(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_content_type(&mut self) {
        self._content_type = ::std::option::Option::None;
    }

    pub fn has_content_type(&self) -> bool {
        match self._content_type {
            ::std::option::Option::Some(AttachedText_oneof__content_type::content_type(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_content_type(&mut self, v: ::std::string::String) {
        self._content_type = ::std::option::Option::Some(AttachedText_oneof__content_type::content_type(v))
    }

    // Mutable pointer to the field.
    pub fn mut_content_type(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(AttachedText_oneof__content_type::content_type(_)) = self._content_type {
        } else {
            self._content_type = ::std::option::Option::Some(AttachedText_oneof__content_type::content_type(::std::string::String::new()));
        }
        match self._content_type {
            ::std::option::Option::Some(AttachedText_oneof__content_type::content_type(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_content_type(&mut self) -> ::std::string::String {
        if self.has_content_type() {
            match self._content_type.take() {
                ::std::option::Option::Some(AttachedText_oneof__content_type::content_type(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string encoding = 2;


    pub fn get_encoding(&self) -> &str {
        match self._encoding {
            ::std::option::Option::Some(AttachedText_oneof__encoding::encoding(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_encoding(&mut self) {
        self._encoding = ::std::option::Option::None;
    }

    pub fn has_encoding(&self) -> bool {
        match self._encoding {
            ::std::option::Option::Some(AttachedText_oneof__encoding::encoding(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_encoding(&mut self, v: ::std::string::String) {
        self._encoding = ::std::option::Option::Some(AttachedText_oneof__encoding::encoding(v))
    }

    // Mutable pointer to the field.
    pub fn mut_encoding(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(AttachedText_oneof__encoding::encoding(_)) = self._encoding {
        } else {
            self._encoding = ::std::option::Option::Some(AttachedText_oneof__encoding::encoding(::std::string::String::new()));
        }
        match self._encoding {
            ::std::option::Option::Some(AttachedText_oneof__encoding::encoding(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_encoding(&mut self) -> ::std::string::String {
        if self.has_encoding() {
            match self._encoding.take() {
                ::std::option::Option::Some(AttachedText_oneof__encoding::encoding(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string value = 3;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AttachedText {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._content_type = ::std::option::Option::Some(AttachedText_oneof__content_type::content_type(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._encoding = ::std::option::Option::Some(AttachedText_oneof__encoding::encoding(is.read_string()?));
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.value);
        }
        if let ::std::option::Option::Some(ref v) = self._content_type {
            match v {
                &AttachedText_oneof__content_type::content_type(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._encoding {
            match v {
                &AttachedText_oneof__encoding::encoding(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.value.is_empty() {
            os.write_string(3, &self.value)?;
        }
        if let ::std::option::Option::Some(ref v) = self._content_type {
            match v {
                &AttachedText_oneof__content_type::content_type(ref v) => {
                    os.write_string(1, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._encoding {
            match v {
                &AttachedText_oneof__encoding::encoding(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttachedText {
        AttachedText::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "content_type",
                AttachedText::has_content_type,
                AttachedText::get_content_type,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "encoding",
                AttachedText::has_encoding,
                AttachedText::get_encoding,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &AttachedText| { &m.value },
                |m: &mut AttachedText| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AttachedText>(
                "AttachedText",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AttachedText {
        static instance: ::protobuf::rt::LazyV2<AttachedText> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AttachedText::new)
    }
}

impl ::protobuf::Clear for AttachedText {
    fn clear(&mut self) {
        self._content_type = ::std::option::Option::None;
        self._encoding = ::std::option::Option::None;
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttachedText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttachedText {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Bom {
    // message fields
    pub spec_version: ::std::string::String,
    pub components: ::protobuf::RepeatedField<Component>,
    pub services: ::protobuf::RepeatedField<Service>,
    pub external_references: ::protobuf::RepeatedField<ExternalReference>,
    pub dependencies: ::protobuf::RepeatedField<Dependency>,
    pub compositions: ::protobuf::RepeatedField<Composition>,
    // message oneof groups
    pub _version: ::std::option::Option<Bom_oneof__version>,
    pub _serial_number: ::std::option::Option<Bom_oneof__serial_number>,
    pub _metadata: ::std::option::Option<Bom_oneof__metadata>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Bom {
    fn default() -> &'a Bom {
        <Bom as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Bom_oneof__version {
    version(i32),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Bom_oneof__serial_number {
    serial_number(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Bom_oneof__metadata {
    metadata(Metadata),
}

impl Bom {
    pub fn new() -> Bom {
        ::std::default::Default::default()
    }

    // string spec_version = 1;


    pub fn get_spec_version(&self) -> &str {
        &self.spec_version
    }
    pub fn clear_spec_version(&mut self) {
        self.spec_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_spec_version(&mut self, v: ::std::string::String) {
        self.spec_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec_version(&mut self) -> &mut ::std::string::String {
        &mut self.spec_version
    }

    // Take field
    pub fn take_spec_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.spec_version, ::std::string::String::new())
    }

    // int32 version = 2;


    pub fn get_version(&self) -> i32 {
        match self._version {
            ::std::option::Option::Some(Bom_oneof__version::version(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_version(&mut self) {
        self._version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        match self._version {
            ::std::option::Option::Some(Bom_oneof__version::version(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self._version = ::std::option::Option::Some(Bom_oneof__version::version(v))
    }

    // string serial_number = 3;


    pub fn get_serial_number(&self) -> &str {
        match self._serial_number {
            ::std::option::Option::Some(Bom_oneof__serial_number::serial_number(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_serial_number(&mut self) {
        self._serial_number = ::std::option::Option::None;
    }

    pub fn has_serial_number(&self) -> bool {
        match self._serial_number {
            ::std::option::Option::Some(Bom_oneof__serial_number::serial_number(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_serial_number(&mut self, v: ::std::string::String) {
        self._serial_number = ::std::option::Option::Some(Bom_oneof__serial_number::serial_number(v))
    }

    // Mutable pointer to the field.
    pub fn mut_serial_number(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Bom_oneof__serial_number::serial_number(_)) = self._serial_number {
        } else {
            self._serial_number = ::std::option::Option::Some(Bom_oneof__serial_number::serial_number(::std::string::String::new()));
        }
        match self._serial_number {
            ::std::option::Option::Some(Bom_oneof__serial_number::serial_number(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_serial_number(&mut self) -> ::std::string::String {
        if self.has_serial_number() {
            match self._serial_number.take() {
                ::std::option::Option::Some(Bom_oneof__serial_number::serial_number(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .cyclonedx.v1_3.Metadata metadata = 4;


    pub fn get_metadata(&self) -> &Metadata {
        match self._metadata {
            ::std::option::Option::Some(Bom_oneof__metadata::metadata(ref v)) => v,
            _ => <Metadata as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_metadata(&mut self) {
        self._metadata = ::std::option::Option::None;
    }

    pub fn has_metadata(&self) -> bool {
        match self._metadata {
            ::std::option::Option::Some(Bom_oneof__metadata::metadata(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: Metadata) {
        self._metadata = ::std::option::Option::Some(Bom_oneof__metadata::metadata(v))
    }

    // Mutable pointer to the field.
    pub fn mut_metadata(&mut self) -> &mut Metadata {
        if let ::std::option::Option::Some(Bom_oneof__metadata::metadata(_)) = self._metadata {
        } else {
            self._metadata = ::std::option::Option::Some(Bom_oneof__metadata::metadata(Metadata::new()));
        }
        match self._metadata {
            ::std::option::Option::Some(Bom_oneof__metadata::metadata(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_metadata(&mut self) -> Metadata {
        if self.has_metadata() {
            match self._metadata.take() {
                ::std::option::Option::Some(Bom_oneof__metadata::metadata(v)) => v,
                _ => panic!(),
            }
        } else {
            Metadata::new()
        }
    }

    // repeated .cyclonedx.v1_3.Component components = 5;


    pub fn get_components(&self) -> &[Component] {
        &self.components
    }
    pub fn clear_components(&mut self) {
        self.components.clear();
    }

    // Param is passed by value, moved
    pub fn set_components(&mut self, v: ::protobuf::RepeatedField<Component>) {
        self.components = v;
    }

    // Mutable pointer to the field.
    pub fn mut_components(&mut self) -> &mut ::protobuf::RepeatedField<Component> {
        &mut self.components
    }

    // Take field
    pub fn take_components(&mut self) -> ::protobuf::RepeatedField<Component> {
        ::std::mem::replace(&mut self.components, ::protobuf::RepeatedField::new())
    }

    // repeated .cyclonedx.v1_3.Service services = 6;


    pub fn get_services(&self) -> &[Service] {
        &self.services
    }
    pub fn clear_services(&mut self) {
        self.services.clear();
    }

    // Param is passed by value, moved
    pub fn set_services(&mut self, v: ::protobuf::RepeatedField<Service>) {
        self.services = v;
    }

    // Mutable pointer to the field.
    pub fn mut_services(&mut self) -> &mut ::protobuf::RepeatedField<Service> {
        &mut self.services
    }

    // Take field
    pub fn take_services(&mut self) -> ::protobuf::RepeatedField<Service> {
        ::std::mem::replace(&mut self.services, ::protobuf::RepeatedField::new())
    }

    // repeated .cyclonedx.v1_3.ExternalReference external_references = 7;


    pub fn get_external_references(&self) -> &[ExternalReference] {
        &self.external_references
    }
    pub fn clear_external_references(&mut self) {
        self.external_references.clear();
    }

    // Param is passed by value, moved
    pub fn set_external_references(&mut self, v: ::protobuf::RepeatedField<ExternalReference>) {
        self.external_references = v;
    }

    // Mutable pointer to the field.
    pub fn mut_external_references(&mut self) -> &mut ::protobuf::RepeatedField<ExternalReference> {
        &mut self.external_references
    }

    // Take field
    pub fn take_external_references(&mut self) -> ::protobuf::RepeatedField<ExternalReference> {
        ::std::mem::replace(&mut self.external_references, ::protobuf::RepeatedField::new())
    }

    // repeated .cyclonedx.v1_3.Dependency dependencies = 8;


    pub fn get_dependencies(&self) -> &[Dependency] {
        &self.dependencies
    }
    pub fn clear_dependencies(&mut self) {
        self.dependencies.clear();
    }

    // Param is passed by value, moved
    pub fn set_dependencies(&mut self, v: ::protobuf::RepeatedField<Dependency>) {
        self.dependencies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dependencies(&mut self) -> &mut ::protobuf::RepeatedField<Dependency> {
        &mut self.dependencies
    }

    // Take field
    pub fn take_dependencies(&mut self) -> ::protobuf::RepeatedField<Dependency> {
        ::std::mem::replace(&mut self.dependencies, ::protobuf::RepeatedField::new())
    }

    // repeated .cyclonedx.v1_3.Composition compositions = 9;


    pub fn get_compositions(&self) -> &[Composition] {
        &self.compositions
    }
    pub fn clear_compositions(&mut self) {
        self.compositions.clear();
    }

    // Param is passed by value, moved
    pub fn set_compositions(&mut self, v: ::protobuf::RepeatedField<Composition>) {
        self.compositions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_compositions(&mut self) -> &mut ::protobuf::RepeatedField<Composition> {
        &mut self.compositions
    }

    // Take field
    pub fn take_compositions(&mut self) -> ::protobuf::RepeatedField<Composition> {
        ::std::mem::replace(&mut self.compositions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Bom {
    fn is_initialized(&self) -> bool {
        if let Some(Bom_oneof__metadata::metadata(ref v)) = self._metadata {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.components {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.services {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.external_references {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dependencies {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.compositions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.spec_version)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._version = ::std::option::Option::Some(Bom_oneof__version::version(is.read_int32()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._serial_number = ::std::option::Option::Some(Bom_oneof__serial_number::serial_number(is.read_string()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._metadata = ::std::option::Option::Some(Bom_oneof__metadata::metadata(is.read_message()?));
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.components)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.services)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.external_references)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dependencies)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.compositions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.spec_version.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.spec_version);
        }
        for value in &self.components {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.services {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.external_references {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.dependencies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.compositions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let ::std::option::Option::Some(ref v) = self._version {
            match v {
                &Bom_oneof__version::version(v) => {
                    my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._serial_number {
            match v {
                &Bom_oneof__serial_number::serial_number(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._metadata {
            match v {
                &Bom_oneof__metadata::metadata(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.spec_version.is_empty() {
            os.write_string(1, &self.spec_version)?;
        }
        for v in &self.components {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.services {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.external_references {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.dependencies {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.compositions {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let ::std::option::Option::Some(ref v) = self._version {
            match v {
                &Bom_oneof__version::version(v) => {
                    os.write_int32(2, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._serial_number {
            match v {
                &Bom_oneof__serial_number::serial_number(ref v) => {
                    os.write_string(3, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._metadata {
            match v {
                &Bom_oneof__metadata::metadata(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Bom {
        Bom::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "spec_version",
                |m: &Bom| { &m.spec_version },
                |m: &mut Bom| { &mut m.spec_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor::<_>(
                "version",
                Bom::has_version,
                Bom::get_version,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "serial_number",
                Bom::has_serial_number,
                Bom::get_serial_number,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Metadata>(
                "metadata",
                Bom::has_metadata,
                Bom::get_metadata,
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Component>>(
                "components",
                |m: &Bom| { &m.components },
                |m: &mut Bom| { &mut m.components },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Service>>(
                "services",
                |m: &Bom| { &m.services },
                |m: &mut Bom| { &mut m.services },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalReference>>(
                "external_references",
                |m: &Bom| { &m.external_references },
                |m: &mut Bom| { &mut m.external_references },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Dependency>>(
                "dependencies",
                |m: &Bom| { &m.dependencies },
                |m: &mut Bom| { &mut m.dependencies },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Composition>>(
                "compositions",
                |m: &Bom| { &m.compositions },
                |m: &mut Bom| { &mut m.compositions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Bom>(
                "Bom",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Bom {
        static instance: ::protobuf::rt::LazyV2<Bom> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Bom::new)
    }
}

impl ::protobuf::Clear for Bom {
    fn clear(&mut self) {
        self.spec_version.clear();
        self._version = ::std::option::Option::None;
        self._serial_number = ::std::option::Option::None;
        self._metadata = ::std::option::Option::None;
        self.components.clear();
        self.services.clear();
        self.external_references.clear();
        self.dependencies.clear();
        self.compositions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Bom {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Bom {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Commit {
    // message oneof groups
    pub _uid: ::std::option::Option<Commit_oneof__uid>,
    pub _url: ::std::option::Option<Commit_oneof__url>,
    pub _author: ::std::option::Option<Commit_oneof__author>,
    pub _committer: ::std::option::Option<Commit_oneof__committer>,
    pub _message: ::std::option::Option<Commit_oneof__message>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Commit {
    fn default() -> &'a Commit {
        <Commit as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Commit_oneof__uid {
    uid(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Commit_oneof__url {
    url(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Commit_oneof__author {
    author(IdentifiableAction),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Commit_oneof__committer {
    committer(IdentifiableAction),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Commit_oneof__message {
    message(::std::string::String),
}

impl Commit {
    pub fn new() -> Commit {
        ::std::default::Default::default()
    }

    // string uid = 1;


    pub fn get_uid(&self) -> &str {
        match self._uid {
            ::std::option::Option::Some(Commit_oneof__uid::uid(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_uid(&mut self) {
        self._uid = ::std::option::Option::None;
    }

    pub fn has_uid(&self) -> bool {
        match self._uid {
            ::std::option::Option::Some(Commit_oneof__uid::uid(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self._uid = ::std::option::Option::Some(Commit_oneof__uid::uid(v))
    }

    // Mutable pointer to the field.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Commit_oneof__uid::uid(_)) = self._uid {
        } else {
            self._uid = ::std::option::Option::Some(Commit_oneof__uid::uid(::std::string::String::new()));
        }
        match self._uid {
            ::std::option::Option::Some(Commit_oneof__uid::uid(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        if self.has_uid() {
            match self._uid.take() {
                ::std::option::Option::Some(Commit_oneof__uid::uid(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string url = 2;


    pub fn get_url(&self) -> &str {
        match self._url {
            ::std::option::Option::Some(Commit_oneof__url::url(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_url(&mut self) {
        self._url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        match self._url {
            ::std::option::Option::Some(Commit_oneof__url::url(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self._url = ::std::option::Option::Some(Commit_oneof__url::url(v))
    }

    // Mutable pointer to the field.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Commit_oneof__url::url(_)) = self._url {
        } else {
            self._url = ::std::option::Option::Some(Commit_oneof__url::url(::std::string::String::new()));
        }
        match self._url {
            ::std::option::Option::Some(Commit_oneof__url::url(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        if self.has_url() {
            match self._url.take() {
                ::std::option::Option::Some(Commit_oneof__url::url(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .cyclonedx.v1_3.IdentifiableAction author = 3;


    pub fn get_author(&self) -> &IdentifiableAction {
        match self._author {
            ::std::option::Option::Some(Commit_oneof__author::author(ref v)) => v,
            _ => <IdentifiableAction as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_author(&mut self) {
        self._author = ::std::option::Option::None;
    }

    pub fn has_author(&self) -> bool {
        match self._author {
            ::std::option::Option::Some(Commit_oneof__author::author(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_author(&mut self, v: IdentifiableAction) {
        self._author = ::std::option::Option::Some(Commit_oneof__author::author(v))
    }

    // Mutable pointer to the field.
    pub fn mut_author(&mut self) -> &mut IdentifiableAction {
        if let ::std::option::Option::Some(Commit_oneof__author::author(_)) = self._author {
        } else {
            self._author = ::std::option::Option::Some(Commit_oneof__author::author(IdentifiableAction::new()));
        }
        match self._author {
            ::std::option::Option::Some(Commit_oneof__author::author(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_author(&mut self) -> IdentifiableAction {
        if self.has_author() {
            match self._author.take() {
                ::std::option::Option::Some(Commit_oneof__author::author(v)) => v,
                _ => panic!(),
            }
        } else {
            IdentifiableAction::new()
        }
    }

    // .cyclonedx.v1_3.IdentifiableAction committer = 4;


    pub fn get_committer(&self) -> &IdentifiableAction {
        match self._committer {
            ::std::option::Option::Some(Commit_oneof__committer::committer(ref v)) => v,
            _ => <IdentifiableAction as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_committer(&mut self) {
        self._committer = ::std::option::Option::None;
    }

    pub fn has_committer(&self) -> bool {
        match self._committer {
            ::std::option::Option::Some(Commit_oneof__committer::committer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_committer(&mut self, v: IdentifiableAction) {
        self._committer = ::std::option::Option::Some(Commit_oneof__committer::committer(v))
    }

    // Mutable pointer to the field.
    pub fn mut_committer(&mut self) -> &mut IdentifiableAction {
        if let ::std::option::Option::Some(Commit_oneof__committer::committer(_)) = self._committer {
        } else {
            self._committer = ::std::option::Option::Some(Commit_oneof__committer::committer(IdentifiableAction::new()));
        }
        match self._committer {
            ::std::option::Option::Some(Commit_oneof__committer::committer(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_committer(&mut self) -> IdentifiableAction {
        if self.has_committer() {
            match self._committer.take() {
                ::std::option::Option::Some(Commit_oneof__committer::committer(v)) => v,
                _ => panic!(),
            }
        } else {
            IdentifiableAction::new()
        }
    }

    // string message = 5;


    pub fn get_message(&self) -> &str {
        match self._message {
            ::std::option::Option::Some(Commit_oneof__message::message(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_message(&mut self) {
        self._message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        match self._message {
            ::std::option::Option::Some(Commit_oneof__message::message(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self._message = ::std::option::Option::Some(Commit_oneof__message::message(v))
    }

    // Mutable pointer to the field.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Commit_oneof__message::message(_)) = self._message {
        } else {
            self._message = ::std::option::Option::Some(Commit_oneof__message::message(::std::string::String::new()));
        }
        match self._message {
            ::std::option::Option::Some(Commit_oneof__message::message(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        if self.has_message() {
            match self._message.take() {
                ::std::option::Option::Some(Commit_oneof__message::message(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for Commit {
    fn is_initialized(&self) -> bool {
        if let Some(Commit_oneof__author::author(ref v)) = self._author {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Commit_oneof__committer::committer(ref v)) = self._committer {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._uid = ::std::option::Option::Some(Commit_oneof__uid::uid(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._url = ::std::option::Option::Some(Commit_oneof__url::url(is.read_string()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._author = ::std::option::Option::Some(Commit_oneof__author::author(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._committer = ::std::option::Option::Some(Commit_oneof__committer::committer(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._message = ::std::option::Option::Some(Commit_oneof__message::message(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self._uid {
            match v {
                &Commit_oneof__uid::uid(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._url {
            match v {
                &Commit_oneof__url::url(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._author {
            match v {
                &Commit_oneof__author::author(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._committer {
            match v {
                &Commit_oneof__committer::committer(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._message {
            match v {
                &Commit_oneof__message::message(ref v) => {
                    my_size += ::protobuf::rt::string_size(5, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self._uid {
            match v {
                &Commit_oneof__uid::uid(ref v) => {
                    os.write_string(1, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._url {
            match v {
                &Commit_oneof__url::url(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._author {
            match v {
                &Commit_oneof__author::author(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._committer {
            match v {
                &Commit_oneof__committer::committer(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._message {
            match v {
                &Commit_oneof__message::message(ref v) => {
                    os.write_string(5, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Commit {
        Commit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "uid",
                Commit::has_uid,
                Commit::get_uid,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "url",
                Commit::has_url,
                Commit::get_url,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, IdentifiableAction>(
                "author",
                Commit::has_author,
                Commit::get_author,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, IdentifiableAction>(
                "committer",
                Commit::has_committer,
                Commit::get_committer,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "message",
                Commit::has_message,
                Commit::get_message,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Commit>(
                "Commit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Commit {
        static instance: ::protobuf::rt::LazyV2<Commit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Commit::new)
    }
}

impl ::protobuf::Clear for Commit {
    fn clear(&mut self) {
        self._uid = ::std::option::Option::None;
        self._url = ::std::option::Option::None;
        self._author = ::std::option::Option::None;
        self._committer = ::std::option::Option::None;
        self._message = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Commit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Commit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Component {
    // message fields
    pub field_type: Classification,
    pub name: ::std::string::String,
    pub version: ::std::string::String,
    pub hashes: ::protobuf::RepeatedField<Hash>,
    pub licenses: ::protobuf::RepeatedField<LicenseChoice>,
    pub external_references: ::protobuf::RepeatedField<ExternalReference>,
    pub components: ::protobuf::RepeatedField<Component>,
    pub properties: ::protobuf::RepeatedField<Property>,
    pub evidence: ::protobuf::RepeatedField<Evidence>,
    // message oneof groups
    pub _mime_type: ::std::option::Option<Component_oneof__mime_type>,
    pub _bom_ref: ::std::option::Option<Component_oneof__bom_ref>,
    pub _supplier: ::std::option::Option<Component_oneof__supplier>,
    pub _author: ::std::option::Option<Component_oneof__author>,
    pub _publisher: ::std::option::Option<Component_oneof__publisher>,
    pub _group: ::std::option::Option<Component_oneof__group>,
    pub _description: ::std::option::Option<Component_oneof__description>,
    pub _scope: ::std::option::Option<Component_oneof__scope>,
    pub _copyright: ::std::option::Option<Component_oneof__copyright>,
    pub _cpe: ::std::option::Option<Component_oneof__cpe>,
    pub _purl: ::std::option::Option<Component_oneof__purl>,
    pub _swid: ::std::option::Option<Component_oneof__swid>,
    pub _modified: ::std::option::Option<Component_oneof__modified>,
    pub _pedigree: ::std::option::Option<Component_oneof__pedigree>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Component {
    fn default() -> &'a Component {
        <Component as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Component_oneof__mime_type {
    mime_type(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Component_oneof__bom_ref {
    bom_ref(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Component_oneof__supplier {
    supplier(OrganizationalEntity),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Component_oneof__author {
    author(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Component_oneof__publisher {
    publisher(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Component_oneof__group {
    group(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Component_oneof__description {
    description(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Component_oneof__scope {
    scope(Scope),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Component_oneof__copyright {
    copyright(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Component_oneof__cpe {
    cpe(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Component_oneof__purl {
    purl(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Component_oneof__swid {
    swid(Swid),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Component_oneof__modified {
    modified(bool),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Component_oneof__pedigree {
    pedigree(Pedigree),
}

impl Component {
    pub fn new() -> Component {
        ::std::default::Default::default()
    }

    // .cyclonedx.v1_3.Classification type = 1;


    pub fn get_field_type(&self) -> Classification {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = Classification::CLASSIFICATION_NULL;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Classification) {
        self.field_type = v;
    }

    // string mime_type = 2;


    pub fn get_mime_type(&self) -> &str {
        match self._mime_type {
            ::std::option::Option::Some(Component_oneof__mime_type::mime_type(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_mime_type(&mut self) {
        self._mime_type = ::std::option::Option::None;
    }

    pub fn has_mime_type(&self) -> bool {
        match self._mime_type {
            ::std::option::Option::Some(Component_oneof__mime_type::mime_type(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mime_type(&mut self, v: ::std::string::String) {
        self._mime_type = ::std::option::Option::Some(Component_oneof__mime_type::mime_type(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mime_type(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Component_oneof__mime_type::mime_type(_)) = self._mime_type {
        } else {
            self._mime_type = ::std::option::Option::Some(Component_oneof__mime_type::mime_type(::std::string::String::new()));
        }
        match self._mime_type {
            ::std::option::Option::Some(Component_oneof__mime_type::mime_type(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mime_type(&mut self) -> ::std::string::String {
        if self.has_mime_type() {
            match self._mime_type.take() {
                ::std::option::Option::Some(Component_oneof__mime_type::mime_type(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string bom_ref = 3;


    pub fn get_bom_ref(&self) -> &str {
        match self._bom_ref {
            ::std::option::Option::Some(Component_oneof__bom_ref::bom_ref(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_bom_ref(&mut self) {
        self._bom_ref = ::std::option::Option::None;
    }

    pub fn has_bom_ref(&self) -> bool {
        match self._bom_ref {
            ::std::option::Option::Some(Component_oneof__bom_ref::bom_ref(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bom_ref(&mut self, v: ::std::string::String) {
        self._bom_ref = ::std::option::Option::Some(Component_oneof__bom_ref::bom_ref(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bom_ref(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Component_oneof__bom_ref::bom_ref(_)) = self._bom_ref {
        } else {
            self._bom_ref = ::std::option::Option::Some(Component_oneof__bom_ref::bom_ref(::std::string::String::new()));
        }
        match self._bom_ref {
            ::std::option::Option::Some(Component_oneof__bom_ref::bom_ref(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bom_ref(&mut self) -> ::std::string::String {
        if self.has_bom_ref() {
            match self._bom_ref.take() {
                ::std::option::Option::Some(Component_oneof__bom_ref::bom_ref(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .cyclonedx.v1_3.OrganizationalEntity supplier = 4;


    pub fn get_supplier(&self) -> &OrganizationalEntity {
        match self._supplier {
            ::std::option::Option::Some(Component_oneof__supplier::supplier(ref v)) => v,
            _ => <OrganizationalEntity as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_supplier(&mut self) {
        self._supplier = ::std::option::Option::None;
    }

    pub fn has_supplier(&self) -> bool {
        match self._supplier {
            ::std::option::Option::Some(Component_oneof__supplier::supplier(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_supplier(&mut self, v: OrganizationalEntity) {
        self._supplier = ::std::option::Option::Some(Component_oneof__supplier::supplier(v))
    }

    // Mutable pointer to the field.
    pub fn mut_supplier(&mut self) -> &mut OrganizationalEntity {
        if let ::std::option::Option::Some(Component_oneof__supplier::supplier(_)) = self._supplier {
        } else {
            self._supplier = ::std::option::Option::Some(Component_oneof__supplier::supplier(OrganizationalEntity::new()));
        }
        match self._supplier {
            ::std::option::Option::Some(Component_oneof__supplier::supplier(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_supplier(&mut self) -> OrganizationalEntity {
        if self.has_supplier() {
            match self._supplier.take() {
                ::std::option::Option::Some(Component_oneof__supplier::supplier(v)) => v,
                _ => panic!(),
            }
        } else {
            OrganizationalEntity::new()
        }
    }

    // string author = 5;


    pub fn get_author(&self) -> &str {
        match self._author {
            ::std::option::Option::Some(Component_oneof__author::author(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_author(&mut self) {
        self._author = ::std::option::Option::None;
    }

    pub fn has_author(&self) -> bool {
        match self._author {
            ::std::option::Option::Some(Component_oneof__author::author(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_author(&mut self, v: ::std::string::String) {
        self._author = ::std::option::Option::Some(Component_oneof__author::author(v))
    }

    // Mutable pointer to the field.
    pub fn mut_author(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Component_oneof__author::author(_)) = self._author {
        } else {
            self._author = ::std::option::Option::Some(Component_oneof__author::author(::std::string::String::new()));
        }
        match self._author {
            ::std::option::Option::Some(Component_oneof__author::author(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_author(&mut self) -> ::std::string::String {
        if self.has_author() {
            match self._author.take() {
                ::std::option::Option::Some(Component_oneof__author::author(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string publisher = 6;


    pub fn get_publisher(&self) -> &str {
        match self._publisher {
            ::std::option::Option::Some(Component_oneof__publisher::publisher(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_publisher(&mut self) {
        self._publisher = ::std::option::Option::None;
    }

    pub fn has_publisher(&self) -> bool {
        match self._publisher {
            ::std::option::Option::Some(Component_oneof__publisher::publisher(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_publisher(&mut self, v: ::std::string::String) {
        self._publisher = ::std::option::Option::Some(Component_oneof__publisher::publisher(v))
    }

    // Mutable pointer to the field.
    pub fn mut_publisher(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Component_oneof__publisher::publisher(_)) = self._publisher {
        } else {
            self._publisher = ::std::option::Option::Some(Component_oneof__publisher::publisher(::std::string::String::new()));
        }
        match self._publisher {
            ::std::option::Option::Some(Component_oneof__publisher::publisher(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_publisher(&mut self) -> ::std::string::String {
        if self.has_publisher() {
            match self._publisher.take() {
                ::std::option::Option::Some(Component_oneof__publisher::publisher(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string group = 7;


    pub fn get_group(&self) -> &str {
        match self._group {
            ::std::option::Option::Some(Component_oneof__group::group(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_group(&mut self) {
        self._group = ::std::option::Option::None;
    }

    pub fn has_group(&self) -> bool {
        match self._group {
            ::std::option::Option::Some(Component_oneof__group::group(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::std::string::String) {
        self._group = ::std::option::Option::Some(Component_oneof__group::group(v))
    }

    // Mutable pointer to the field.
    pub fn mut_group(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Component_oneof__group::group(_)) = self._group {
        } else {
            self._group = ::std::option::Option::Some(Component_oneof__group::group(::std::string::String::new()));
        }
        match self._group {
            ::std::option::Option::Some(Component_oneof__group::group(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_group(&mut self) -> ::std::string::String {
        if self.has_group() {
            match self._group.take() {
                ::std::option::Option::Some(Component_oneof__group::group(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string name = 8;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string version = 9;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // string description = 10;


    pub fn get_description(&self) -> &str {
        match self._description {
            ::std::option::Option::Some(Component_oneof__description::description(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_description(&mut self) {
        self._description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        match self._description {
            ::std::option::Option::Some(Component_oneof__description::description(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self._description = ::std::option::Option::Some(Component_oneof__description::description(v))
    }

    // Mutable pointer to the field.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Component_oneof__description::description(_)) = self._description {
        } else {
            self._description = ::std::option::Option::Some(Component_oneof__description::description(::std::string::String::new()));
        }
        match self._description {
            ::std::option::Option::Some(Component_oneof__description::description(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        if self.has_description() {
            match self._description.take() {
                ::std::option::Option::Some(Component_oneof__description::description(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .cyclonedx.v1_3.Scope scope = 11;


    pub fn get_scope(&self) -> Scope {
        match self._scope {
            ::std::option::Option::Some(Component_oneof__scope::scope(v)) => v,
            _ => Scope::SCOPE_UNSPECIFIED,
        }
    }
    pub fn clear_scope(&mut self) {
        self._scope = ::std::option::Option::None;
    }

    pub fn has_scope(&self) -> bool {
        match self._scope {
            ::std::option::Option::Some(Component_oneof__scope::scope(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_scope(&mut self, v: Scope) {
        self._scope = ::std::option::Option::Some(Component_oneof__scope::scope(v))
    }

    // repeated .cyclonedx.v1_3.Hash hashes = 12;


    pub fn get_hashes(&self) -> &[Hash] {
        &self.hashes
    }
    pub fn clear_hashes(&mut self) {
        self.hashes.clear();
    }

    // Param is passed by value, moved
    pub fn set_hashes(&mut self, v: ::protobuf::RepeatedField<Hash>) {
        self.hashes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hashes(&mut self) -> &mut ::protobuf::RepeatedField<Hash> {
        &mut self.hashes
    }

    // Take field
    pub fn take_hashes(&mut self) -> ::protobuf::RepeatedField<Hash> {
        ::std::mem::replace(&mut self.hashes, ::protobuf::RepeatedField::new())
    }

    // repeated .cyclonedx.v1_3.LicenseChoice licenses = 13;


    pub fn get_licenses(&self) -> &[LicenseChoice] {
        &self.licenses
    }
    pub fn clear_licenses(&mut self) {
        self.licenses.clear();
    }

    // Param is passed by value, moved
    pub fn set_licenses(&mut self, v: ::protobuf::RepeatedField<LicenseChoice>) {
        self.licenses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_licenses(&mut self) -> &mut ::protobuf::RepeatedField<LicenseChoice> {
        &mut self.licenses
    }

    // Take field
    pub fn take_licenses(&mut self) -> ::protobuf::RepeatedField<LicenseChoice> {
        ::std::mem::replace(&mut self.licenses, ::protobuf::RepeatedField::new())
    }

    // string copyright = 14;


    pub fn get_copyright(&self) -> &str {
        match self._copyright {
            ::std::option::Option::Some(Component_oneof__copyright::copyright(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_copyright(&mut self) {
        self._copyright = ::std::option::Option::None;
    }

    pub fn has_copyright(&self) -> bool {
        match self._copyright {
            ::std::option::Option::Some(Component_oneof__copyright::copyright(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_copyright(&mut self, v: ::std::string::String) {
        self._copyright = ::std::option::Option::Some(Component_oneof__copyright::copyright(v))
    }

    // Mutable pointer to the field.
    pub fn mut_copyright(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Component_oneof__copyright::copyright(_)) = self._copyright {
        } else {
            self._copyright = ::std::option::Option::Some(Component_oneof__copyright::copyright(::std::string::String::new()));
        }
        match self._copyright {
            ::std::option::Option::Some(Component_oneof__copyright::copyright(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_copyright(&mut self) -> ::std::string::String {
        if self.has_copyright() {
            match self._copyright.take() {
                ::std::option::Option::Some(Component_oneof__copyright::copyright(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string cpe = 15;


    pub fn get_cpe(&self) -> &str {
        match self._cpe {
            ::std::option::Option::Some(Component_oneof__cpe::cpe(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_cpe(&mut self) {
        self._cpe = ::std::option::Option::None;
    }

    pub fn has_cpe(&self) -> bool {
        match self._cpe {
            ::std::option::Option::Some(Component_oneof__cpe::cpe(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cpe(&mut self, v: ::std::string::String) {
        self._cpe = ::std::option::Option::Some(Component_oneof__cpe::cpe(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cpe(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Component_oneof__cpe::cpe(_)) = self._cpe {
        } else {
            self._cpe = ::std::option::Option::Some(Component_oneof__cpe::cpe(::std::string::String::new()));
        }
        match self._cpe {
            ::std::option::Option::Some(Component_oneof__cpe::cpe(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cpe(&mut self) -> ::std::string::String {
        if self.has_cpe() {
            match self._cpe.take() {
                ::std::option::Option::Some(Component_oneof__cpe::cpe(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string purl = 16;


    pub fn get_purl(&self) -> &str {
        match self._purl {
            ::std::option::Option::Some(Component_oneof__purl::purl(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_purl(&mut self) {
        self._purl = ::std::option::Option::None;
    }

    pub fn has_purl(&self) -> bool {
        match self._purl {
            ::std::option::Option::Some(Component_oneof__purl::purl(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_purl(&mut self, v: ::std::string::String) {
        self._purl = ::std::option::Option::Some(Component_oneof__purl::purl(v))
    }

    // Mutable pointer to the field.
    pub fn mut_purl(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Component_oneof__purl::purl(_)) = self._purl {
        } else {
            self._purl = ::std::option::Option::Some(Component_oneof__purl::purl(::std::string::String::new()));
        }
        match self._purl {
            ::std::option::Option::Some(Component_oneof__purl::purl(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_purl(&mut self) -> ::std::string::String {
        if self.has_purl() {
            match self._purl.take() {
                ::std::option::Option::Some(Component_oneof__purl::purl(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .cyclonedx.v1_3.Swid swid = 17;


    pub fn get_swid(&self) -> &Swid {
        match self._swid {
            ::std::option::Option::Some(Component_oneof__swid::swid(ref v)) => v,
            _ => <Swid as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_swid(&mut self) {
        self._swid = ::std::option::Option::None;
    }

    pub fn has_swid(&self) -> bool {
        match self._swid {
            ::std::option::Option::Some(Component_oneof__swid::swid(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_swid(&mut self, v: Swid) {
        self._swid = ::std::option::Option::Some(Component_oneof__swid::swid(v))
    }

    // Mutable pointer to the field.
    pub fn mut_swid(&mut self) -> &mut Swid {
        if let ::std::option::Option::Some(Component_oneof__swid::swid(_)) = self._swid {
        } else {
            self._swid = ::std::option::Option::Some(Component_oneof__swid::swid(Swid::new()));
        }
        match self._swid {
            ::std::option::Option::Some(Component_oneof__swid::swid(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_swid(&mut self) -> Swid {
        if self.has_swid() {
            match self._swid.take() {
                ::std::option::Option::Some(Component_oneof__swid::swid(v)) => v,
                _ => panic!(),
            }
        } else {
            Swid::new()
        }
    }

    // bool modified = 18;


    pub fn get_modified(&self) -> bool {
        match self._modified {
            ::std::option::Option::Some(Component_oneof__modified::modified(v)) => v,
            _ => false,
        }
    }
    pub fn clear_modified(&mut self) {
        self._modified = ::std::option::Option::None;
    }

    pub fn has_modified(&self) -> bool {
        match self._modified {
            ::std::option::Option::Some(Component_oneof__modified::modified(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_modified(&mut self, v: bool) {
        self._modified = ::std::option::Option::Some(Component_oneof__modified::modified(v))
    }

    // .cyclonedx.v1_3.Pedigree pedigree = 19;


    pub fn get_pedigree(&self) -> &Pedigree {
        match self._pedigree {
            ::std::option::Option::Some(Component_oneof__pedigree::pedigree(ref v)) => v,
            _ => <Pedigree as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_pedigree(&mut self) {
        self._pedigree = ::std::option::Option::None;
    }

    pub fn has_pedigree(&self) -> bool {
        match self._pedigree {
            ::std::option::Option::Some(Component_oneof__pedigree::pedigree(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pedigree(&mut self, v: Pedigree) {
        self._pedigree = ::std::option::Option::Some(Component_oneof__pedigree::pedigree(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pedigree(&mut self) -> &mut Pedigree {
        if let ::std::option::Option::Some(Component_oneof__pedigree::pedigree(_)) = self._pedigree {
        } else {
            self._pedigree = ::std::option::Option::Some(Component_oneof__pedigree::pedigree(Pedigree::new()));
        }
        match self._pedigree {
            ::std::option::Option::Some(Component_oneof__pedigree::pedigree(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pedigree(&mut self) -> Pedigree {
        if self.has_pedigree() {
            match self._pedigree.take() {
                ::std::option::Option::Some(Component_oneof__pedigree::pedigree(v)) => v,
                _ => panic!(),
            }
        } else {
            Pedigree::new()
        }
    }

    // repeated .cyclonedx.v1_3.ExternalReference external_references = 20;


    pub fn get_external_references(&self) -> &[ExternalReference] {
        &self.external_references
    }
    pub fn clear_external_references(&mut self) {
        self.external_references.clear();
    }

    // Param is passed by value, moved
    pub fn set_external_references(&mut self, v: ::protobuf::RepeatedField<ExternalReference>) {
        self.external_references = v;
    }

    // Mutable pointer to the field.
    pub fn mut_external_references(&mut self) -> &mut ::protobuf::RepeatedField<ExternalReference> {
        &mut self.external_references
    }

    // Take field
    pub fn take_external_references(&mut self) -> ::protobuf::RepeatedField<ExternalReference> {
        ::std::mem::replace(&mut self.external_references, ::protobuf::RepeatedField::new())
    }

    // repeated .cyclonedx.v1_3.Component components = 21;


    pub fn get_components(&self) -> &[Component] {
        &self.components
    }
    pub fn clear_components(&mut self) {
        self.components.clear();
    }

    // Param is passed by value, moved
    pub fn set_components(&mut self, v: ::protobuf::RepeatedField<Component>) {
        self.components = v;
    }

    // Mutable pointer to the field.
    pub fn mut_components(&mut self) -> &mut ::protobuf::RepeatedField<Component> {
        &mut self.components
    }

    // Take field
    pub fn take_components(&mut self) -> ::protobuf::RepeatedField<Component> {
        ::std::mem::replace(&mut self.components, ::protobuf::RepeatedField::new())
    }

    // repeated .cyclonedx.v1_3.Property properties = 22;


    pub fn get_properties(&self) -> &[Property] {
        &self.properties
    }
    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::protobuf::RepeatedField<Property>) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properties(&mut self) -> &mut ::protobuf::RepeatedField<Property> {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::protobuf::RepeatedField<Property> {
        ::std::mem::replace(&mut self.properties, ::protobuf::RepeatedField::new())
    }

    // repeated .cyclonedx.v1_3.Evidence evidence = 23;


    pub fn get_evidence(&self) -> &[Evidence] {
        &self.evidence
    }
    pub fn clear_evidence(&mut self) {
        self.evidence.clear();
    }

    // Param is passed by value, moved
    pub fn set_evidence(&mut self, v: ::protobuf::RepeatedField<Evidence>) {
        self.evidence = v;
    }

    // Mutable pointer to the field.
    pub fn mut_evidence(&mut self) -> &mut ::protobuf::RepeatedField<Evidence> {
        &mut self.evidence
    }

    // Take field
    pub fn take_evidence(&mut self) -> ::protobuf::RepeatedField<Evidence> {
        ::std::mem::replace(&mut self.evidence, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Component {
    fn is_initialized(&self) -> bool {
        if let Some(Component_oneof__supplier::supplier(ref v)) = self._supplier {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.hashes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.licenses {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(Component_oneof__swid::swid(ref v)) = self._swid {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Component_oneof__pedigree::pedigree(ref v)) = self._pedigree {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.external_references {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.components {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.properties {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.evidence {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._mime_type = ::std::option::Option::Some(Component_oneof__mime_type::mime_type(is.read_string()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._bom_ref = ::std::option::Option::Some(Component_oneof__bom_ref::bom_ref(is.read_string()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._supplier = ::std::option::Option::Some(Component_oneof__supplier::supplier(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._author = ::std::option::Option::Some(Component_oneof__author::author(is.read_string()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._publisher = ::std::option::Option::Some(Component_oneof__publisher::publisher(is.read_string()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._group = ::std::option::Option::Some(Component_oneof__group::group(is.read_string()?));
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._description = ::std::option::Option::Some(Component_oneof__description::description(is.read_string()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._scope = ::std::option::Option::Some(Component_oneof__scope::scope(is.read_enum()?));
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.hashes)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.licenses)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._copyright = ::std::option::Option::Some(Component_oneof__copyright::copyright(is.read_string()?));
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._cpe = ::std::option::Option::Some(Component_oneof__cpe::cpe(is.read_string()?));
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._purl = ::std::option::Option::Some(Component_oneof__purl::purl(is.read_string()?));
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._swid = ::std::option::Option::Some(Component_oneof__swid::swid(is.read_message()?));
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._modified = ::std::option::Option::Some(Component_oneof__modified::modified(is.read_bool()?));
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._pedigree = ::std::option::Option::Some(Component_oneof__pedigree::pedigree(is.read_message()?));
                },
                20 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.external_references)?;
                },
                21 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.components)?;
                },
                22 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.properties)?;
                },
                23 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.evidence)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != Classification::CLASSIFICATION_NULL {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.name);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.version);
        }
        for value in &self.hashes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.licenses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.external_references {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.components {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.properties {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.evidence {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let ::std::option::Option::Some(ref v) = self._mime_type {
            match v {
                &Component_oneof__mime_type::mime_type(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._bom_ref {
            match v {
                &Component_oneof__bom_ref::bom_ref(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._supplier {
            match v {
                &Component_oneof__supplier::supplier(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._author {
            match v {
                &Component_oneof__author::author(ref v) => {
                    my_size += ::protobuf::rt::string_size(5, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._publisher {
            match v {
                &Component_oneof__publisher::publisher(ref v) => {
                    my_size += ::protobuf::rt::string_size(6, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._group {
            match v {
                &Component_oneof__group::group(ref v) => {
                    my_size += ::protobuf::rt::string_size(7, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._description {
            match v {
                &Component_oneof__description::description(ref v) => {
                    my_size += ::protobuf::rt::string_size(10, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._scope {
            match v {
                &Component_oneof__scope::scope(v) => {
                    my_size += ::protobuf::rt::enum_size(11, v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._copyright {
            match v {
                &Component_oneof__copyright::copyright(ref v) => {
                    my_size += ::protobuf::rt::string_size(14, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._cpe {
            match v {
                &Component_oneof__cpe::cpe(ref v) => {
                    my_size += ::protobuf::rt::string_size(15, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._purl {
            match v {
                &Component_oneof__purl::purl(ref v) => {
                    my_size += ::protobuf::rt::string_size(16, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._swid {
            match v {
                &Component_oneof__swid::swid(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._modified {
            match v {
                &Component_oneof__modified::modified(v) => {
                    my_size += 3;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._pedigree {
            match v {
                &Component_oneof__pedigree::pedigree(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != Classification::CLASSIFICATION_NULL {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if !self.name.is_empty() {
            os.write_string(8, &self.name)?;
        }
        if !self.version.is_empty() {
            os.write_string(9, &self.version)?;
        }
        for v in &self.hashes {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.licenses {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.external_references {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.components {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.properties {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.evidence {
            os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let ::std::option::Option::Some(ref v) = self._mime_type {
            match v {
                &Component_oneof__mime_type::mime_type(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._bom_ref {
            match v {
                &Component_oneof__bom_ref::bom_ref(ref v) => {
                    os.write_string(3, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._supplier {
            match v {
                &Component_oneof__supplier::supplier(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._author {
            match v {
                &Component_oneof__author::author(ref v) => {
                    os.write_string(5, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._publisher {
            match v {
                &Component_oneof__publisher::publisher(ref v) => {
                    os.write_string(6, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._group {
            match v {
                &Component_oneof__group::group(ref v) => {
                    os.write_string(7, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._description {
            match v {
                &Component_oneof__description::description(ref v) => {
                    os.write_string(10, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._scope {
            match v {
                &Component_oneof__scope::scope(v) => {
                    os.write_enum(11, ::protobuf::ProtobufEnum::value(&v))?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._copyright {
            match v {
                &Component_oneof__copyright::copyright(ref v) => {
                    os.write_string(14, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._cpe {
            match v {
                &Component_oneof__cpe::cpe(ref v) => {
                    os.write_string(15, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._purl {
            match v {
                &Component_oneof__purl::purl(ref v) => {
                    os.write_string(16, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._swid {
            match v {
                &Component_oneof__swid::swid(ref v) => {
                    os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._modified {
            match v {
                &Component_oneof__modified::modified(v) => {
                    os.write_bool(18, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._pedigree {
            match v {
                &Component_oneof__pedigree::pedigree(ref v) => {
                    os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Component {
        Component::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Classification>>(
                "type",
                |m: &Component| { &m.field_type },
                |m: &mut Component| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "mime_type",
                Component::has_mime_type,
                Component::get_mime_type,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "bom_ref",
                Component::has_bom_ref,
                Component::get_bom_ref,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OrganizationalEntity>(
                "supplier",
                Component::has_supplier,
                Component::get_supplier,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "author",
                Component::has_author,
                Component::get_author,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "publisher",
                Component::has_publisher,
                Component::get_publisher,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "group",
                Component::has_group,
                Component::get_group,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Component| { &m.name },
                |m: &mut Component| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version",
                |m: &Component| { &m.version },
                |m: &mut Component| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "description",
                Component::has_description,
                Component::get_description,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, Scope>(
                "scope",
                Component::has_scope,
                Component::get_scope,
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Hash>>(
                "hashes",
                |m: &Component| { &m.hashes },
                |m: &mut Component| { &mut m.hashes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LicenseChoice>>(
                "licenses",
                |m: &Component| { &m.licenses },
                |m: &mut Component| { &mut m.licenses },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "copyright",
                Component::has_copyright,
                Component::get_copyright,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "cpe",
                Component::has_cpe,
                Component::get_cpe,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "purl",
                Component::has_purl,
                Component::get_purl,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Swid>(
                "swid",
                Component::has_swid,
                Component::get_swid,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "modified",
                Component::has_modified,
                Component::get_modified,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Pedigree>(
                "pedigree",
                Component::has_pedigree,
                Component::get_pedigree,
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalReference>>(
                "external_references",
                |m: &Component| { &m.external_references },
                |m: &mut Component| { &mut m.external_references },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Component>>(
                "components",
                |m: &Component| { &m.components },
                |m: &mut Component| { &mut m.components },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Property>>(
                "properties",
                |m: &Component| { &m.properties },
                |m: &mut Component| { &mut m.properties },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Evidence>>(
                "evidence",
                |m: &Component| { &m.evidence },
                |m: &mut Component| { &mut m.evidence },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Component>(
                "Component",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Component {
        static instance: ::protobuf::rt::LazyV2<Component> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Component::new)
    }
}

impl ::protobuf::Clear for Component {
    fn clear(&mut self) {
        self.field_type = Classification::CLASSIFICATION_NULL;
        self._mime_type = ::std::option::Option::None;
        self._bom_ref = ::std::option::Option::None;
        self._supplier = ::std::option::Option::None;
        self._author = ::std::option::Option::None;
        self._publisher = ::std::option::Option::None;
        self._group = ::std::option::Option::None;
        self.name.clear();
        self.version.clear();
        self._description = ::std::option::Option::None;
        self._scope = ::std::option::Option::None;
        self.hashes.clear();
        self.licenses.clear();
        self._copyright = ::std::option::Option::None;
        self._cpe = ::std::option::Option::None;
        self._purl = ::std::option::Option::None;
        self._swid = ::std::option::Option::None;
        self._modified = ::std::option::Option::None;
        self._pedigree = ::std::option::Option::None;
        self.external_references.clear();
        self.components.clear();
        self.properties.clear();
        self.evidence.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Component {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Component {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DataClassification {
    // message fields
    pub flow: DataFlow,
    pub value: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataClassification {
    fn default() -> &'a DataClassification {
        <DataClassification as ::protobuf::Message>::default_instance()
    }
}

impl DataClassification {
    pub fn new() -> DataClassification {
        ::std::default::Default::default()
    }

    // .cyclonedx.v1_3.DataFlow flow = 1;


    pub fn get_flow(&self) -> DataFlow {
        self.flow
    }
    pub fn clear_flow(&mut self) {
        self.flow = DataFlow::DATA_FLOW_NULL;
    }

    // Param is passed by value, moved
    pub fn set_flow(&mut self, v: DataFlow) {
        self.flow = v;
    }

    // string value = 2;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DataClassification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.flow, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.flow != DataFlow::DATA_FLOW_NULL {
            my_size += ::protobuf::rt::enum_size(1, self.flow);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.flow != DataFlow::DATA_FLOW_NULL {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.flow))?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataClassification {
        DataClassification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DataFlow>>(
                "flow",
                |m: &DataClassification| { &m.flow },
                |m: &mut DataClassification| { &mut m.flow },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &DataClassification| { &m.value },
                |m: &mut DataClassification| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataClassification>(
                "DataClassification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataClassification {
        static instance: ::protobuf::rt::LazyV2<DataClassification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataClassification::new)
    }
}

impl ::protobuf::Clear for DataClassification {
    fn clear(&mut self) {
        self.flow = DataFlow::DATA_FLOW_NULL;
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataClassification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataClassification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Dependency {
    // message fields
    pub field_ref: ::std::string::String,
    pub dependencies: ::protobuf::RepeatedField<Dependency>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Dependency {
    fn default() -> &'a Dependency {
        <Dependency as ::protobuf::Message>::default_instance()
    }
}

impl Dependency {
    pub fn new() -> Dependency {
        ::std::default::Default::default()
    }

    // string ref = 1;


    pub fn get_field_ref(&self) -> &str {
        &self.field_ref
    }
    pub fn clear_field_ref(&mut self) {
        self.field_ref.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_ref(&mut self, v: ::std::string::String) {
        self.field_ref = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_ref(&mut self) -> &mut ::std::string::String {
        &mut self.field_ref
    }

    // Take field
    pub fn take_field_ref(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_ref, ::std::string::String::new())
    }

    // repeated .cyclonedx.v1_3.Dependency dependencies = 2;


    pub fn get_dependencies(&self) -> &[Dependency] {
        &self.dependencies
    }
    pub fn clear_dependencies(&mut self) {
        self.dependencies.clear();
    }

    // Param is passed by value, moved
    pub fn set_dependencies(&mut self, v: ::protobuf::RepeatedField<Dependency>) {
        self.dependencies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dependencies(&mut self) -> &mut ::protobuf::RepeatedField<Dependency> {
        &mut self.dependencies
    }

    // Take field
    pub fn take_dependencies(&mut self) -> ::protobuf::RepeatedField<Dependency> {
        ::std::mem::replace(&mut self.dependencies, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Dependency {
    fn is_initialized(&self) -> bool {
        for v in &self.dependencies {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_ref)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dependencies)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.field_ref.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.field_ref);
        }
        for value in &self.dependencies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.field_ref.is_empty() {
            os.write_string(1, &self.field_ref)?;
        }
        for v in &self.dependencies {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Dependency {
        Dependency::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ref",
                |m: &Dependency| { &m.field_ref },
                |m: &mut Dependency| { &mut m.field_ref },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Dependency>>(
                "dependencies",
                |m: &Dependency| { &m.dependencies },
                |m: &mut Dependency| { &mut m.dependencies },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Dependency>(
                "Dependency",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Dependency {
        static instance: ::protobuf::rt::LazyV2<Dependency> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Dependency::new)
    }
}

impl ::protobuf::Clear for Dependency {
    fn clear(&mut self) {
        self.field_ref.clear();
        self.dependencies.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Dependency {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Dependency {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Diff {
    // message oneof groups
    pub _text: ::std::option::Option<Diff_oneof__text>,
    pub _url: ::std::option::Option<Diff_oneof__url>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Diff {
    fn default() -> &'a Diff {
        <Diff as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Diff_oneof__text {
    text(AttachedText),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Diff_oneof__url {
    url(::std::string::String),
}

impl Diff {
    pub fn new() -> Diff {
        ::std::default::Default::default()
    }

    // .cyclonedx.v1_3.AttachedText text = 1;


    pub fn get_text(&self) -> &AttachedText {
        match self._text {
            ::std::option::Option::Some(Diff_oneof__text::text(ref v)) => v,
            _ => <AttachedText as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_text(&mut self) {
        self._text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        match self._text {
            ::std::option::Option::Some(Diff_oneof__text::text(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: AttachedText) {
        self._text = ::std::option::Option::Some(Diff_oneof__text::text(v))
    }

    // Mutable pointer to the field.
    pub fn mut_text(&mut self) -> &mut AttachedText {
        if let ::std::option::Option::Some(Diff_oneof__text::text(_)) = self._text {
        } else {
            self._text = ::std::option::Option::Some(Diff_oneof__text::text(AttachedText::new()));
        }
        match self._text {
            ::std::option::Option::Some(Diff_oneof__text::text(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_text(&mut self) -> AttachedText {
        if self.has_text() {
            match self._text.take() {
                ::std::option::Option::Some(Diff_oneof__text::text(v)) => v,
                _ => panic!(),
            }
        } else {
            AttachedText::new()
        }
    }

    // string url = 2;


    pub fn get_url(&self) -> &str {
        match self._url {
            ::std::option::Option::Some(Diff_oneof__url::url(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_url(&mut self) {
        self._url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        match self._url {
            ::std::option::Option::Some(Diff_oneof__url::url(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self._url = ::std::option::Option::Some(Diff_oneof__url::url(v))
    }

    // Mutable pointer to the field.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Diff_oneof__url::url(_)) = self._url {
        } else {
            self._url = ::std::option::Option::Some(Diff_oneof__url::url(::std::string::String::new()));
        }
        match self._url {
            ::std::option::Option::Some(Diff_oneof__url::url(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        if self.has_url() {
            match self._url.take() {
                ::std::option::Option::Some(Diff_oneof__url::url(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for Diff {
    fn is_initialized(&self) -> bool {
        if let Some(Diff_oneof__text::text(ref v)) = self._text {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._text = ::std::option::Option::Some(Diff_oneof__text::text(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._url = ::std::option::Option::Some(Diff_oneof__url::url(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self._text {
            match v {
                &Diff_oneof__text::text(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._url {
            match v {
                &Diff_oneof__url::url(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self._text {
            match v {
                &Diff_oneof__text::text(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._url {
            match v {
                &Diff_oneof__url::url(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Diff {
        Diff::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AttachedText>(
                "text",
                Diff::has_text,
                Diff::get_text,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "url",
                Diff::has_url,
                Diff::get_url,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Diff>(
                "Diff",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Diff {
        static instance: ::protobuf::rt::LazyV2<Diff> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Diff::new)
    }
}

impl ::protobuf::Clear for Diff {
    fn clear(&mut self) {
        self._text = ::std::option::Option::None;
        self._url = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Diff {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Diff {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ExternalReference {
    // message fields
    pub field_type: ExternalReferenceType,
    pub url: ::std::string::String,
    pub hashes: ::protobuf::RepeatedField<Hash>,
    // message oneof groups
    pub _comment: ::std::option::Option<ExternalReference_oneof__comment>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExternalReference {
    fn default() -> &'a ExternalReference {
        <ExternalReference as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum ExternalReference_oneof__comment {
    comment(::std::string::String),
}

impl ExternalReference {
    pub fn new() -> ExternalReference {
        ::std::default::Default::default()
    }

    // .cyclonedx.v1_3.ExternalReferenceType type = 1;


    pub fn get_field_type(&self) -> ExternalReferenceType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ExternalReferenceType::EXTERNAL_REFERENCE_TYPE_OTHER;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ExternalReferenceType) {
        self.field_type = v;
    }

    // string url = 2;


    pub fn get_url(&self) -> &str {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.url, ::std::string::String::new())
    }

    // string comment = 3;


    pub fn get_comment(&self) -> &str {
        match self._comment {
            ::std::option::Option::Some(ExternalReference_oneof__comment::comment(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_comment(&mut self) {
        self._comment = ::std::option::Option::None;
    }

    pub fn has_comment(&self) -> bool {
        match self._comment {
            ::std::option::Option::Some(ExternalReference_oneof__comment::comment(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_comment(&mut self, v: ::std::string::String) {
        self._comment = ::std::option::Option::Some(ExternalReference_oneof__comment::comment(v))
    }

    // Mutable pointer to the field.
    pub fn mut_comment(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(ExternalReference_oneof__comment::comment(_)) = self._comment {
        } else {
            self._comment = ::std::option::Option::Some(ExternalReference_oneof__comment::comment(::std::string::String::new()));
        }
        match self._comment {
            ::std::option::Option::Some(ExternalReference_oneof__comment::comment(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_comment(&mut self) -> ::std::string::String {
        if self.has_comment() {
            match self._comment.take() {
                ::std::option::Option::Some(ExternalReference_oneof__comment::comment(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // repeated .cyclonedx.v1_3.Hash hashes = 4;


    pub fn get_hashes(&self) -> &[Hash] {
        &self.hashes
    }
    pub fn clear_hashes(&mut self) {
        self.hashes.clear();
    }

    // Param is passed by value, moved
    pub fn set_hashes(&mut self, v: ::protobuf::RepeatedField<Hash>) {
        self.hashes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hashes(&mut self) -> &mut ::protobuf::RepeatedField<Hash> {
        &mut self.hashes
    }

    // Take field
    pub fn take_hashes(&mut self) -> ::protobuf::RepeatedField<Hash> {
        ::std::mem::replace(&mut self.hashes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ExternalReference {
    fn is_initialized(&self) -> bool {
        for v in &self.hashes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.url)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._comment = ::std::option::Option::Some(ExternalReference_oneof__comment::comment(is.read_string()?));
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.hashes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != ExternalReferenceType::EXTERNAL_REFERENCE_TYPE_OTHER {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.url);
        }
        for value in &self.hashes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let ::std::option::Option::Some(ref v) = self._comment {
            match v {
                &ExternalReference_oneof__comment::comment(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != ExternalReferenceType::EXTERNAL_REFERENCE_TYPE_OTHER {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if !self.url.is_empty() {
            os.write_string(2, &self.url)?;
        }
        for v in &self.hashes {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let ::std::option::Option::Some(ref v) = self._comment {
            match v {
                &ExternalReference_oneof__comment::comment(ref v) => {
                    os.write_string(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExternalReference {
        ExternalReference::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ExternalReferenceType>>(
                "type",
                |m: &ExternalReference| { &m.field_type },
                |m: &mut ExternalReference| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &ExternalReference| { &m.url },
                |m: &mut ExternalReference| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "comment",
                ExternalReference::has_comment,
                ExternalReference::get_comment,
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Hash>>(
                "hashes",
                |m: &ExternalReference| { &m.hashes },
                |m: &mut ExternalReference| { &mut m.hashes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExternalReference>(
                "ExternalReference",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExternalReference {
        static instance: ::protobuf::rt::LazyV2<ExternalReference> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExternalReference::new)
    }
}

impl ::protobuf::Clear for ExternalReference {
    fn clear(&mut self) {
        self.field_type = ExternalReferenceType::EXTERNAL_REFERENCE_TYPE_OTHER;
        self.url.clear();
        self._comment = ::std::option::Option::None;
        self.hashes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExternalReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExternalReference {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Hash {
    // message fields
    pub alg: HashAlg,
    pub value: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Hash {
    fn default() -> &'a Hash {
        <Hash as ::protobuf::Message>::default_instance()
    }
}

impl Hash {
    pub fn new() -> Hash {
        ::std::default::Default::default()
    }

    // .cyclonedx.v1_3.HashAlg alg = 1;


    pub fn get_alg(&self) -> HashAlg {
        self.alg
    }
    pub fn clear_alg(&mut self) {
        self.alg = HashAlg::HASH_ALG_NULL;
    }

    // Param is passed by value, moved
    pub fn set_alg(&mut self, v: HashAlg) {
        self.alg = v;
    }

    // string value = 2;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Hash {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.alg, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.alg != HashAlg::HASH_ALG_NULL {
            my_size += ::protobuf::rt::enum_size(1, self.alg);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.alg != HashAlg::HASH_ALG_NULL {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.alg))?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Hash {
        Hash::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<HashAlg>>(
                "alg",
                |m: &Hash| { &m.alg },
                |m: &mut Hash| { &mut m.alg },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &Hash| { &m.value },
                |m: &mut Hash| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Hash>(
                "Hash",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Hash {
        static instance: ::protobuf::rt::LazyV2<Hash> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Hash::new)
    }
}

impl ::protobuf::Clear for Hash {
    fn clear(&mut self) {
        self.alg = HashAlg::HASH_ALG_NULL;
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Hash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Hash {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct IdentifiableAction {
    // message oneof groups
    pub _timestamp: ::std::option::Option<IdentifiableAction_oneof__timestamp>,
    pub _name: ::std::option::Option<IdentifiableAction_oneof__name>,
    pub _email: ::std::option::Option<IdentifiableAction_oneof__email>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IdentifiableAction {
    fn default() -> &'a IdentifiableAction {
        <IdentifiableAction as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum IdentifiableAction_oneof__timestamp {
    timestamp(::protobuf::well_known_types::Timestamp),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum IdentifiableAction_oneof__name {
    name(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum IdentifiableAction_oneof__email {
    email(::std::string::String),
}

impl IdentifiableAction {
    pub fn new() -> IdentifiableAction {
        ::std::default::Default::default()
    }

    // .google.protobuf.Timestamp timestamp = 1;


    pub fn get_timestamp(&self) -> &::protobuf::well_known_types::Timestamp {
        match self._timestamp {
            ::std::option::Option::Some(IdentifiableAction_oneof__timestamp::timestamp(ref v)) => v,
            _ => <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_timestamp(&mut self) {
        self._timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        match self._timestamp {
            ::std::option::Option::Some(IdentifiableAction_oneof__timestamp::timestamp(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self._timestamp = ::std::option::Option::Some(IdentifiableAction_oneof__timestamp::timestamp(v))
    }

    // Mutable pointer to the field.
    pub fn mut_timestamp(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if let ::std::option::Option::Some(IdentifiableAction_oneof__timestamp::timestamp(_)) = self._timestamp {
        } else {
            self._timestamp = ::std::option::Option::Some(IdentifiableAction_oneof__timestamp::timestamp(::protobuf::well_known_types::Timestamp::new()));
        }
        match self._timestamp {
            ::std::option::Option::Some(IdentifiableAction_oneof__timestamp::timestamp(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_timestamp(&mut self) -> ::protobuf::well_known_types::Timestamp {
        if self.has_timestamp() {
            match self._timestamp.take() {
                ::std::option::Option::Some(IdentifiableAction_oneof__timestamp::timestamp(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Timestamp::new()
        }
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        match self._name {
            ::std::option::Option::Some(IdentifiableAction_oneof__name::name(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_name(&mut self) {
        self._name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        match self._name {
            ::std::option::Option::Some(IdentifiableAction_oneof__name::name(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self._name = ::std::option::Option::Some(IdentifiableAction_oneof__name::name(v))
    }

    // Mutable pointer to the field.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(IdentifiableAction_oneof__name::name(_)) = self._name {
        } else {
            self._name = ::std::option::Option::Some(IdentifiableAction_oneof__name::name(::std::string::String::new()));
        }
        match self._name {
            ::std::option::Option::Some(IdentifiableAction_oneof__name::name(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        if self.has_name() {
            match self._name.take() {
                ::std::option::Option::Some(IdentifiableAction_oneof__name::name(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string email = 3;


    pub fn get_email(&self) -> &str {
        match self._email {
            ::std::option::Option::Some(IdentifiableAction_oneof__email::email(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_email(&mut self) {
        self._email = ::std::option::Option::None;
    }

    pub fn has_email(&self) -> bool {
        match self._email {
            ::std::option::Option::Some(IdentifiableAction_oneof__email::email(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_email(&mut self, v: ::std::string::String) {
        self._email = ::std::option::Option::Some(IdentifiableAction_oneof__email::email(v))
    }

    // Mutable pointer to the field.
    pub fn mut_email(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(IdentifiableAction_oneof__email::email(_)) = self._email {
        } else {
            self._email = ::std::option::Option::Some(IdentifiableAction_oneof__email::email(::std::string::String::new()));
        }
        match self._email {
            ::std::option::Option::Some(IdentifiableAction_oneof__email::email(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_email(&mut self) -> ::std::string::String {
        if self.has_email() {
            match self._email.take() {
                ::std::option::Option::Some(IdentifiableAction_oneof__email::email(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for IdentifiableAction {
    fn is_initialized(&self) -> bool {
        if let Some(IdentifiableAction_oneof__timestamp::timestamp(ref v)) = self._timestamp {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._timestamp = ::std::option::Option::Some(IdentifiableAction_oneof__timestamp::timestamp(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._name = ::std::option::Option::Some(IdentifiableAction_oneof__name::name(is.read_string()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._email = ::std::option::Option::Some(IdentifiableAction_oneof__email::email(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self._timestamp {
            match v {
                &IdentifiableAction_oneof__timestamp::timestamp(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._name {
            match v {
                &IdentifiableAction_oneof__name::name(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._email {
            match v {
                &IdentifiableAction_oneof__email::email(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self._timestamp {
            match v {
                &IdentifiableAction_oneof__timestamp::timestamp(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._name {
            match v {
                &IdentifiableAction_oneof__name::name(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._email {
            match v {
                &IdentifiableAction_oneof__email::email(ref v) => {
                    os.write_string(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IdentifiableAction {
        IdentifiableAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Timestamp>(
                "timestamp",
                IdentifiableAction::has_timestamp,
                IdentifiableAction::get_timestamp,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "name",
                IdentifiableAction::has_name,
                IdentifiableAction::get_name,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "email",
                IdentifiableAction::has_email,
                IdentifiableAction::get_email,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IdentifiableAction>(
                "IdentifiableAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IdentifiableAction {
        static instance: ::protobuf::rt::LazyV2<IdentifiableAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IdentifiableAction::new)
    }
}

impl ::protobuf::Clear for IdentifiableAction {
    fn clear(&mut self) {
        self._timestamp = ::std::option::Option::None;
        self._name = ::std::option::Option::None;
        self._email = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IdentifiableAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IdentifiableAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Issue {
    // message fields
    pub field_type: IssueClassification,
    pub references: ::protobuf::RepeatedField<::std::string::String>,
    // message oneof groups
    pub _id: ::std::option::Option<Issue_oneof__id>,
    pub _name: ::std::option::Option<Issue_oneof__name>,
    pub _description: ::std::option::Option<Issue_oneof__description>,
    pub _source: ::std::option::Option<Issue_oneof__source>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Issue {
    fn default() -> &'a Issue {
        <Issue as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Issue_oneof__id {
    id(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Issue_oneof__name {
    name(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Issue_oneof__description {
    description(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Issue_oneof__source {
    source(Source),
}

impl Issue {
    pub fn new() -> Issue {
        ::std::default::Default::default()
    }

    // .cyclonedx.v1_3.IssueClassification type = 1;


    pub fn get_field_type(&self) -> IssueClassification {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = IssueClassification::ISSUE_CLASSIFICATION_NULL;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: IssueClassification) {
        self.field_type = v;
    }

    // string id = 2;


    pub fn get_id(&self) -> &str {
        match self._id {
            ::std::option::Option::Some(Issue_oneof__id::id(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_id(&mut self) {
        self._id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        match self._id {
            ::std::option::Option::Some(Issue_oneof__id::id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self._id = ::std::option::Option::Some(Issue_oneof__id::id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Issue_oneof__id::id(_)) = self._id {
        } else {
            self._id = ::std::option::Option::Some(Issue_oneof__id::id(::std::string::String::new()));
        }
        match self._id {
            ::std::option::Option::Some(Issue_oneof__id::id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        if self.has_id() {
            match self._id.take() {
                ::std::option::Option::Some(Issue_oneof__id::id(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        match self._name {
            ::std::option::Option::Some(Issue_oneof__name::name(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_name(&mut self) {
        self._name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        match self._name {
            ::std::option::Option::Some(Issue_oneof__name::name(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self._name = ::std::option::Option::Some(Issue_oneof__name::name(v))
    }

    // Mutable pointer to the field.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Issue_oneof__name::name(_)) = self._name {
        } else {
            self._name = ::std::option::Option::Some(Issue_oneof__name::name(::std::string::String::new()));
        }
        match self._name {
            ::std::option::Option::Some(Issue_oneof__name::name(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        if self.has_name() {
            match self._name.take() {
                ::std::option::Option::Some(Issue_oneof__name::name(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string description = 4;


    pub fn get_description(&self) -> &str {
        match self._description {
            ::std::option::Option::Some(Issue_oneof__description::description(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_description(&mut self) {
        self._description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        match self._description {
            ::std::option::Option::Some(Issue_oneof__description::description(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self._description = ::std::option::Option::Some(Issue_oneof__description::description(v))
    }

    // Mutable pointer to the field.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Issue_oneof__description::description(_)) = self._description {
        } else {
            self._description = ::std::option::Option::Some(Issue_oneof__description::description(::std::string::String::new()));
        }
        match self._description {
            ::std::option::Option::Some(Issue_oneof__description::description(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        if self.has_description() {
            match self._description.take() {
                ::std::option::Option::Some(Issue_oneof__description::description(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .cyclonedx.v1_3.Source source = 5;


    pub fn get_source(&self) -> &Source {
        match self._source {
            ::std::option::Option::Some(Issue_oneof__source::source(ref v)) => v,
            _ => <Source as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_source(&mut self) {
        self._source = ::std::option::Option::None;
    }

    pub fn has_source(&self) -> bool {
        match self._source {
            ::std::option::Option::Some(Issue_oneof__source::source(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: Source) {
        self._source = ::std::option::Option::Some(Issue_oneof__source::source(v))
    }

    // Mutable pointer to the field.
    pub fn mut_source(&mut self) -> &mut Source {
        if let ::std::option::Option::Some(Issue_oneof__source::source(_)) = self._source {
        } else {
            self._source = ::std::option::Option::Some(Issue_oneof__source::source(Source::new()));
        }
        match self._source {
            ::std::option::Option::Some(Issue_oneof__source::source(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_source(&mut self) -> Source {
        if self.has_source() {
            match self._source.take() {
                ::std::option::Option::Some(Issue_oneof__source::source(v)) => v,
                _ => panic!(),
            }
        } else {
            Source::new()
        }
    }

    // repeated string references = 6;


    pub fn get_references(&self) -> &[::std::string::String] {
        &self.references
    }
    pub fn clear_references(&mut self) {
        self.references.clear();
    }

    // Param is passed by value, moved
    pub fn set_references(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.references = v;
    }

    // Mutable pointer to the field.
    pub fn mut_references(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.references
    }

    // Take field
    pub fn take_references(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.references, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Issue {
    fn is_initialized(&self) -> bool {
        if let Some(Issue_oneof__source::source(ref v)) = self._source {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._id = ::std::option::Option::Some(Issue_oneof__id::id(is.read_string()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._name = ::std::option::Option::Some(Issue_oneof__name::name(is.read_string()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._description = ::std::option::Option::Some(Issue_oneof__description::description(is.read_string()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._source = ::std::option::Option::Some(Issue_oneof__source::source(is.read_message()?));
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.references)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != IssueClassification::ISSUE_CLASSIFICATION_NULL {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        for value in &self.references {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if let ::std::option::Option::Some(ref v) = self._id {
            match v {
                &Issue_oneof__id::id(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._name {
            match v {
                &Issue_oneof__name::name(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._description {
            match v {
                &Issue_oneof__description::description(ref v) => {
                    my_size += ::protobuf::rt::string_size(4, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._source {
            match v {
                &Issue_oneof__source::source(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != IssueClassification::ISSUE_CLASSIFICATION_NULL {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        for v in &self.references {
            os.write_string(6, &v)?;
        };
        if let ::std::option::Option::Some(ref v) = self._id {
            match v {
                &Issue_oneof__id::id(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._name {
            match v {
                &Issue_oneof__name::name(ref v) => {
                    os.write_string(3, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._description {
            match v {
                &Issue_oneof__description::description(ref v) => {
                    os.write_string(4, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._source {
            match v {
                &Issue_oneof__source::source(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Issue {
        Issue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<IssueClassification>>(
                "type",
                |m: &Issue| { &m.field_type },
                |m: &mut Issue| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "id",
                Issue::has_id,
                Issue::get_id,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "name",
                Issue::has_name,
                Issue::get_name,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "description",
                Issue::has_description,
                Issue::get_description,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Source>(
                "source",
                Issue::has_source,
                Issue::get_source,
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "references",
                |m: &Issue| { &m.references },
                |m: &mut Issue| { &mut m.references },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Issue>(
                "Issue",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Issue {
        static instance: ::protobuf::rt::LazyV2<Issue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Issue::new)
    }
}

impl ::protobuf::Clear for Issue {
    fn clear(&mut self) {
        self.field_type = IssueClassification::ISSUE_CLASSIFICATION_NULL;
        self._id = ::std::option::Option::None;
        self._name = ::std::option::Option::None;
        self._description = ::std::option::Option::None;
        self._source = ::std::option::Option::None;
        self.references.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Issue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Issue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Source {
    // message oneof groups
    pub _name: ::std::option::Option<Source_oneof__name>,
    pub _url: ::std::option::Option<Source_oneof__url>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Source {
    fn default() -> &'a Source {
        <Source as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Source_oneof__name {
    name(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Source_oneof__url {
    url(::std::string::String),
}

impl Source {
    pub fn new() -> Source {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        match self._name {
            ::std::option::Option::Some(Source_oneof__name::name(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_name(&mut self) {
        self._name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        match self._name {
            ::std::option::Option::Some(Source_oneof__name::name(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self._name = ::std::option::Option::Some(Source_oneof__name::name(v))
    }

    // Mutable pointer to the field.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Source_oneof__name::name(_)) = self._name {
        } else {
            self._name = ::std::option::Option::Some(Source_oneof__name::name(::std::string::String::new()));
        }
        match self._name {
            ::std::option::Option::Some(Source_oneof__name::name(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        if self.has_name() {
            match self._name.take() {
                ::std::option::Option::Some(Source_oneof__name::name(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string url = 2;


    pub fn get_url(&self) -> &str {
        match self._url {
            ::std::option::Option::Some(Source_oneof__url::url(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_url(&mut self) {
        self._url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        match self._url {
            ::std::option::Option::Some(Source_oneof__url::url(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self._url = ::std::option::Option::Some(Source_oneof__url::url(v))
    }

    // Mutable pointer to the field.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Source_oneof__url::url(_)) = self._url {
        } else {
            self._url = ::std::option::Option::Some(Source_oneof__url::url(::std::string::String::new()));
        }
        match self._url {
            ::std::option::Option::Some(Source_oneof__url::url(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        if self.has_url() {
            match self._url.take() {
                ::std::option::Option::Some(Source_oneof__url::url(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for Source {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._name = ::std::option::Option::Some(Source_oneof__name::name(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._url = ::std::option::Option::Some(Source_oneof__url::url(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self._name {
            match v {
                &Source_oneof__name::name(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._url {
            match v {
                &Source_oneof__url::url(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self._name {
            match v {
                &Source_oneof__name::name(ref v) => {
                    os.write_string(1, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._url {
            match v {
                &Source_oneof__url::url(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Source {
        Source::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "name",
                Source::has_name,
                Source::get_name,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "url",
                Source::has_url,
                Source::get_url,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Source>(
                "Source",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Source {
        static instance: ::protobuf::rt::LazyV2<Source> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Source::new)
    }
}

impl ::protobuf::Clear for Source {
    fn clear(&mut self) {
        self._name = ::std::option::Option::None;
        self._url = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Source {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Source {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct LicenseChoice {
    // message oneof groups
    pub choice: ::std::option::Option<LicenseChoice_oneof_choice>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LicenseChoice {
    fn default() -> &'a LicenseChoice {
        <LicenseChoice as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum LicenseChoice_oneof_choice {
    license(License),
    expression(::std::string::String),
}

impl LicenseChoice {
    pub fn new() -> LicenseChoice {
        ::std::default::Default::default()
    }

    // .cyclonedx.v1_3.License license = 1;


    pub fn get_license(&self) -> &License {
        match self.choice {
            ::std::option::Option::Some(LicenseChoice_oneof_choice::license(ref v)) => v,
            _ => <License as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_license(&mut self) {
        self.choice = ::std::option::Option::None;
    }

    pub fn has_license(&self) -> bool {
        match self.choice {
            ::std::option::Option::Some(LicenseChoice_oneof_choice::license(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_license(&mut self, v: License) {
        self.choice = ::std::option::Option::Some(LicenseChoice_oneof_choice::license(v))
    }

    // Mutable pointer to the field.
    pub fn mut_license(&mut self) -> &mut License {
        if let ::std::option::Option::Some(LicenseChoice_oneof_choice::license(_)) = self.choice {
        } else {
            self.choice = ::std::option::Option::Some(LicenseChoice_oneof_choice::license(License::new()));
        }
        match self.choice {
            ::std::option::Option::Some(LicenseChoice_oneof_choice::license(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_license(&mut self) -> License {
        if self.has_license() {
            match self.choice.take() {
                ::std::option::Option::Some(LicenseChoice_oneof_choice::license(v)) => v,
                _ => panic!(),
            }
        } else {
            License::new()
        }
    }

    // string expression = 2;


    pub fn get_expression(&self) -> &str {
        match self.choice {
            ::std::option::Option::Some(LicenseChoice_oneof_choice::expression(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_expression(&mut self) {
        self.choice = ::std::option::Option::None;
    }

    pub fn has_expression(&self) -> bool {
        match self.choice {
            ::std::option::Option::Some(LicenseChoice_oneof_choice::expression(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_expression(&mut self, v: ::std::string::String) {
        self.choice = ::std::option::Option::Some(LicenseChoice_oneof_choice::expression(v))
    }

    // Mutable pointer to the field.
    pub fn mut_expression(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(LicenseChoice_oneof_choice::expression(_)) = self.choice {
        } else {
            self.choice = ::std::option::Option::Some(LicenseChoice_oneof_choice::expression(::std::string::String::new()));
        }
        match self.choice {
            ::std::option::Option::Some(LicenseChoice_oneof_choice::expression(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_expression(&mut self) -> ::std::string::String {
        if self.has_expression() {
            match self.choice.take() {
                ::std::option::Option::Some(LicenseChoice_oneof_choice::expression(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for LicenseChoice {
    fn is_initialized(&self) -> bool {
        if let Some(LicenseChoice_oneof_choice::license(ref v)) = self.choice {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.choice = ::std::option::Option::Some(LicenseChoice_oneof_choice::license(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.choice = ::std::option::Option::Some(LicenseChoice_oneof_choice::expression(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.choice {
            match v {
                &LicenseChoice_oneof_choice::license(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &LicenseChoice_oneof_choice::expression(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.choice {
            match v {
                &LicenseChoice_oneof_choice::license(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &LicenseChoice_oneof_choice::expression(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LicenseChoice {
        LicenseChoice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, License>(
                "license",
                LicenseChoice::has_license,
                LicenseChoice::get_license,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "expression",
                LicenseChoice::has_expression,
                LicenseChoice::get_expression,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LicenseChoice>(
                "LicenseChoice",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LicenseChoice {
        static instance: ::protobuf::rt::LazyV2<LicenseChoice> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LicenseChoice::new)
    }
}

impl ::protobuf::Clear for LicenseChoice {
    fn clear(&mut self) {
        self.choice = ::std::option::Option::None;
        self.choice = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LicenseChoice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LicenseChoice {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct License {
    // message oneof groups
    pub license: ::std::option::Option<License_oneof_license>,
    pub _text: ::std::option::Option<License_oneof__text>,
    pub _url: ::std::option::Option<License_oneof__url>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a License {
    fn default() -> &'a License {
        <License as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum License_oneof_license {
    id(::std::string::String),
    name(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum License_oneof__text {
    text(AttachedText),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum License_oneof__url {
    url(::std::string::String),
}

impl License {
    pub fn new() -> License {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        match self.license {
            ::std::option::Option::Some(License_oneof_license::id(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_id(&mut self) {
        self.license = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        match self.license {
            ::std::option::Option::Some(License_oneof_license::id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.license = ::std::option::Option::Some(License_oneof_license::id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(License_oneof_license::id(_)) = self.license {
        } else {
            self.license = ::std::option::Option::Some(License_oneof_license::id(::std::string::String::new()));
        }
        match self.license {
            ::std::option::Option::Some(License_oneof_license::id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        if self.has_id() {
            match self.license.take() {
                ::std::option::Option::Some(License_oneof_license::id(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        match self.license {
            ::std::option::Option::Some(License_oneof_license::name(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.license = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        match self.license {
            ::std::option::Option::Some(License_oneof_license::name(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.license = ::std::option::Option::Some(License_oneof_license::name(v))
    }

    // Mutable pointer to the field.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(License_oneof_license::name(_)) = self.license {
        } else {
            self.license = ::std::option::Option::Some(License_oneof_license::name(::std::string::String::new()));
        }
        match self.license {
            ::std::option::Option::Some(License_oneof_license::name(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        if self.has_name() {
            match self.license.take() {
                ::std::option::Option::Some(License_oneof_license::name(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .cyclonedx.v1_3.AttachedText text = 3;


    pub fn get_text(&self) -> &AttachedText {
        match self._text {
            ::std::option::Option::Some(License_oneof__text::text(ref v)) => v,
            _ => <AttachedText as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_text(&mut self) {
        self._text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        match self._text {
            ::std::option::Option::Some(License_oneof__text::text(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: AttachedText) {
        self._text = ::std::option::Option::Some(License_oneof__text::text(v))
    }

    // Mutable pointer to the field.
    pub fn mut_text(&mut self) -> &mut AttachedText {
        if let ::std::option::Option::Some(License_oneof__text::text(_)) = self._text {
        } else {
            self._text = ::std::option::Option::Some(License_oneof__text::text(AttachedText::new()));
        }
        match self._text {
            ::std::option::Option::Some(License_oneof__text::text(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_text(&mut self) -> AttachedText {
        if self.has_text() {
            match self._text.take() {
                ::std::option::Option::Some(License_oneof__text::text(v)) => v,
                _ => panic!(),
            }
        } else {
            AttachedText::new()
        }
    }

    // string url = 4;


    pub fn get_url(&self) -> &str {
        match self._url {
            ::std::option::Option::Some(License_oneof__url::url(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_url(&mut self) {
        self._url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        match self._url {
            ::std::option::Option::Some(License_oneof__url::url(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self._url = ::std::option::Option::Some(License_oneof__url::url(v))
    }

    // Mutable pointer to the field.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(License_oneof__url::url(_)) = self._url {
        } else {
            self._url = ::std::option::Option::Some(License_oneof__url::url(::std::string::String::new()));
        }
        match self._url {
            ::std::option::Option::Some(License_oneof__url::url(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        if self.has_url() {
            match self._url.take() {
                ::std::option::Option::Some(License_oneof__url::url(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for License {
    fn is_initialized(&self) -> bool {
        if let Some(License_oneof__text::text(ref v)) = self._text {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.license = ::std::option::Option::Some(License_oneof_license::id(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.license = ::std::option::Option::Some(License_oneof_license::name(is.read_string()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._text = ::std::option::Option::Some(License_oneof__text::text(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._url = ::std::option::Option::Some(License_oneof__url::url(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.license {
            match v {
                &License_oneof_license::id(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &License_oneof_license::name(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._text {
            match v {
                &License_oneof__text::text(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._url {
            match v {
                &License_oneof__url::url(ref v) => {
                    my_size += ::protobuf::rt::string_size(4, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.license {
            match v {
                &License_oneof_license::id(ref v) => {
                    os.write_string(1, v)?;
                },
                &License_oneof_license::name(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._text {
            match v {
                &License_oneof__text::text(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._url {
            match v {
                &License_oneof__url::url(ref v) => {
                    os.write_string(4, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> License {
        License::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "id",
                License::has_id,
                License::get_id,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "name",
                License::has_name,
                License::get_name,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AttachedText>(
                "text",
                License::has_text,
                License::get_text,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "url",
                License::has_url,
                License::get_url,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<License>(
                "License",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static License {
        static instance: ::protobuf::rt::LazyV2<License> = ::protobuf::rt::LazyV2::INIT;
        instance.get(License::new)
    }
}

impl ::protobuf::Clear for License {
    fn clear(&mut self) {
        self.license = ::std::option::Option::None;
        self.license = ::std::option::Option::None;
        self._text = ::std::option::Option::None;
        self._url = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for License {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for License {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Metadata {
    // message fields
    pub tools: ::protobuf::RepeatedField<Tool>,
    pub authors: ::protobuf::RepeatedField<OrganizationalContact>,
    pub properties: ::protobuf::RepeatedField<Property>,
    // message oneof groups
    pub _timestamp: ::std::option::Option<Metadata_oneof__timestamp>,
    pub _component: ::std::option::Option<Metadata_oneof__component>,
    pub _manufacture: ::std::option::Option<Metadata_oneof__manufacture>,
    pub _supplier: ::std::option::Option<Metadata_oneof__supplier>,
    pub _licenses: ::std::option::Option<Metadata_oneof__licenses>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Metadata {
    fn default() -> &'a Metadata {
        <Metadata as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Metadata_oneof__timestamp {
    timestamp(::protobuf::well_known_types::Timestamp),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Metadata_oneof__component {
    component(Component),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Metadata_oneof__manufacture {
    manufacture(OrganizationalEntity),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Metadata_oneof__supplier {
    supplier(OrganizationalEntity),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Metadata_oneof__licenses {
    licenses(LicenseChoice),
}

impl Metadata {
    pub fn new() -> Metadata {
        ::std::default::Default::default()
    }

    // .google.protobuf.Timestamp timestamp = 1;


    pub fn get_timestamp(&self) -> &::protobuf::well_known_types::Timestamp {
        match self._timestamp {
            ::std::option::Option::Some(Metadata_oneof__timestamp::timestamp(ref v)) => v,
            _ => <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_timestamp(&mut self) {
        self._timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        match self._timestamp {
            ::std::option::Option::Some(Metadata_oneof__timestamp::timestamp(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self._timestamp = ::std::option::Option::Some(Metadata_oneof__timestamp::timestamp(v))
    }

    // Mutable pointer to the field.
    pub fn mut_timestamp(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if let ::std::option::Option::Some(Metadata_oneof__timestamp::timestamp(_)) = self._timestamp {
        } else {
            self._timestamp = ::std::option::Option::Some(Metadata_oneof__timestamp::timestamp(::protobuf::well_known_types::Timestamp::new()));
        }
        match self._timestamp {
            ::std::option::Option::Some(Metadata_oneof__timestamp::timestamp(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_timestamp(&mut self) -> ::protobuf::well_known_types::Timestamp {
        if self.has_timestamp() {
            match self._timestamp.take() {
                ::std::option::Option::Some(Metadata_oneof__timestamp::timestamp(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Timestamp::new()
        }
    }

    // repeated .cyclonedx.v1_3.Tool tools = 2;


    pub fn get_tools(&self) -> &[Tool] {
        &self.tools
    }
    pub fn clear_tools(&mut self) {
        self.tools.clear();
    }

    // Param is passed by value, moved
    pub fn set_tools(&mut self, v: ::protobuf::RepeatedField<Tool>) {
        self.tools = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tools(&mut self) -> &mut ::protobuf::RepeatedField<Tool> {
        &mut self.tools
    }

    // Take field
    pub fn take_tools(&mut self) -> ::protobuf::RepeatedField<Tool> {
        ::std::mem::replace(&mut self.tools, ::protobuf::RepeatedField::new())
    }

    // repeated .cyclonedx.v1_3.OrganizationalContact authors = 3;


    pub fn get_authors(&self) -> &[OrganizationalContact] {
        &self.authors
    }
    pub fn clear_authors(&mut self) {
        self.authors.clear();
    }

    // Param is passed by value, moved
    pub fn set_authors(&mut self, v: ::protobuf::RepeatedField<OrganizationalContact>) {
        self.authors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_authors(&mut self) -> &mut ::protobuf::RepeatedField<OrganizationalContact> {
        &mut self.authors
    }

    // Take field
    pub fn take_authors(&mut self) -> ::protobuf::RepeatedField<OrganizationalContact> {
        ::std::mem::replace(&mut self.authors, ::protobuf::RepeatedField::new())
    }

    // .cyclonedx.v1_3.Component component = 4;


    pub fn get_component(&self) -> &Component {
        match self._component {
            ::std::option::Option::Some(Metadata_oneof__component::component(ref v)) => v,
            _ => <Component as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_component(&mut self) {
        self._component = ::std::option::Option::None;
    }

    pub fn has_component(&self) -> bool {
        match self._component {
            ::std::option::Option::Some(Metadata_oneof__component::component(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_component(&mut self, v: Component) {
        self._component = ::std::option::Option::Some(Metadata_oneof__component::component(v))
    }

    // Mutable pointer to the field.
    pub fn mut_component(&mut self) -> &mut Component {
        if let ::std::option::Option::Some(Metadata_oneof__component::component(_)) = self._component {
        } else {
            self._component = ::std::option::Option::Some(Metadata_oneof__component::component(Component::new()));
        }
        match self._component {
            ::std::option::Option::Some(Metadata_oneof__component::component(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_component(&mut self) -> Component {
        if self.has_component() {
            match self._component.take() {
                ::std::option::Option::Some(Metadata_oneof__component::component(v)) => v,
                _ => panic!(),
            }
        } else {
            Component::new()
        }
    }

    // .cyclonedx.v1_3.OrganizationalEntity manufacture = 5;


    pub fn get_manufacture(&self) -> &OrganizationalEntity {
        match self._manufacture {
            ::std::option::Option::Some(Metadata_oneof__manufacture::manufacture(ref v)) => v,
            _ => <OrganizationalEntity as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_manufacture(&mut self) {
        self._manufacture = ::std::option::Option::None;
    }

    pub fn has_manufacture(&self) -> bool {
        match self._manufacture {
            ::std::option::Option::Some(Metadata_oneof__manufacture::manufacture(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_manufacture(&mut self, v: OrganizationalEntity) {
        self._manufacture = ::std::option::Option::Some(Metadata_oneof__manufacture::manufacture(v))
    }

    // Mutable pointer to the field.
    pub fn mut_manufacture(&mut self) -> &mut OrganizationalEntity {
        if let ::std::option::Option::Some(Metadata_oneof__manufacture::manufacture(_)) = self._manufacture {
        } else {
            self._manufacture = ::std::option::Option::Some(Metadata_oneof__manufacture::manufacture(OrganizationalEntity::new()));
        }
        match self._manufacture {
            ::std::option::Option::Some(Metadata_oneof__manufacture::manufacture(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_manufacture(&mut self) -> OrganizationalEntity {
        if self.has_manufacture() {
            match self._manufacture.take() {
                ::std::option::Option::Some(Metadata_oneof__manufacture::manufacture(v)) => v,
                _ => panic!(),
            }
        } else {
            OrganizationalEntity::new()
        }
    }

    // .cyclonedx.v1_3.OrganizationalEntity supplier = 6;


    pub fn get_supplier(&self) -> &OrganizationalEntity {
        match self._supplier {
            ::std::option::Option::Some(Metadata_oneof__supplier::supplier(ref v)) => v,
            _ => <OrganizationalEntity as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_supplier(&mut self) {
        self._supplier = ::std::option::Option::None;
    }

    pub fn has_supplier(&self) -> bool {
        match self._supplier {
            ::std::option::Option::Some(Metadata_oneof__supplier::supplier(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_supplier(&mut self, v: OrganizationalEntity) {
        self._supplier = ::std::option::Option::Some(Metadata_oneof__supplier::supplier(v))
    }

    // Mutable pointer to the field.
    pub fn mut_supplier(&mut self) -> &mut OrganizationalEntity {
        if let ::std::option::Option::Some(Metadata_oneof__supplier::supplier(_)) = self._supplier {
        } else {
            self._supplier = ::std::option::Option::Some(Metadata_oneof__supplier::supplier(OrganizationalEntity::new()));
        }
        match self._supplier {
            ::std::option::Option::Some(Metadata_oneof__supplier::supplier(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_supplier(&mut self) -> OrganizationalEntity {
        if self.has_supplier() {
            match self._supplier.take() {
                ::std::option::Option::Some(Metadata_oneof__supplier::supplier(v)) => v,
                _ => panic!(),
            }
        } else {
            OrganizationalEntity::new()
        }
    }

    // .cyclonedx.v1_3.LicenseChoice licenses = 7;


    pub fn get_licenses(&self) -> &LicenseChoice {
        match self._licenses {
            ::std::option::Option::Some(Metadata_oneof__licenses::licenses(ref v)) => v,
            _ => <LicenseChoice as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_licenses(&mut self) {
        self._licenses = ::std::option::Option::None;
    }

    pub fn has_licenses(&self) -> bool {
        match self._licenses {
            ::std::option::Option::Some(Metadata_oneof__licenses::licenses(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_licenses(&mut self, v: LicenseChoice) {
        self._licenses = ::std::option::Option::Some(Metadata_oneof__licenses::licenses(v))
    }

    // Mutable pointer to the field.
    pub fn mut_licenses(&mut self) -> &mut LicenseChoice {
        if let ::std::option::Option::Some(Metadata_oneof__licenses::licenses(_)) = self._licenses {
        } else {
            self._licenses = ::std::option::Option::Some(Metadata_oneof__licenses::licenses(LicenseChoice::new()));
        }
        match self._licenses {
            ::std::option::Option::Some(Metadata_oneof__licenses::licenses(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_licenses(&mut self) -> LicenseChoice {
        if self.has_licenses() {
            match self._licenses.take() {
                ::std::option::Option::Some(Metadata_oneof__licenses::licenses(v)) => v,
                _ => panic!(),
            }
        } else {
            LicenseChoice::new()
        }
    }

    // repeated .cyclonedx.v1_3.Property properties = 8;


    pub fn get_properties(&self) -> &[Property] {
        &self.properties
    }
    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::protobuf::RepeatedField<Property>) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properties(&mut self) -> &mut ::protobuf::RepeatedField<Property> {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::protobuf::RepeatedField<Property> {
        ::std::mem::replace(&mut self.properties, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Metadata {
    fn is_initialized(&self) -> bool {
        if let Some(Metadata_oneof__timestamp::timestamp(ref v)) = self._timestamp {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.tools {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.authors {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(Metadata_oneof__component::component(ref v)) = self._component {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Metadata_oneof__manufacture::manufacture(ref v)) = self._manufacture {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Metadata_oneof__supplier::supplier(ref v)) = self._supplier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Metadata_oneof__licenses::licenses(ref v)) = self._licenses {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.properties {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._timestamp = ::std::option::Option::Some(Metadata_oneof__timestamp::timestamp(is.read_message()?));
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tools)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.authors)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._component = ::std::option::Option::Some(Metadata_oneof__component::component(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._manufacture = ::std::option::Option::Some(Metadata_oneof__manufacture::manufacture(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._supplier = ::std::option::Option::Some(Metadata_oneof__supplier::supplier(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._licenses = ::std::option::Option::Some(Metadata_oneof__licenses::licenses(is.read_message()?));
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.properties)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.tools {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.authors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let ::std::option::Option::Some(ref v) = self._timestamp {
            match v {
                &Metadata_oneof__timestamp::timestamp(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._component {
            match v {
                &Metadata_oneof__component::component(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._manufacture {
            match v {
                &Metadata_oneof__manufacture::manufacture(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._supplier {
            match v {
                &Metadata_oneof__supplier::supplier(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._licenses {
            match v {
                &Metadata_oneof__licenses::licenses(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.tools {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.authors {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.properties {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let ::std::option::Option::Some(ref v) = self._timestamp {
            match v {
                &Metadata_oneof__timestamp::timestamp(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._component {
            match v {
                &Metadata_oneof__component::component(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._manufacture {
            match v {
                &Metadata_oneof__manufacture::manufacture(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._supplier {
            match v {
                &Metadata_oneof__supplier::supplier(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._licenses {
            match v {
                &Metadata_oneof__licenses::licenses(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Metadata {
        Metadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Timestamp>(
                "timestamp",
                Metadata::has_timestamp,
                Metadata::get_timestamp,
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Tool>>(
                "tools",
                |m: &Metadata| { &m.tools },
                |m: &mut Metadata| { &mut m.tools },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OrganizationalContact>>(
                "authors",
                |m: &Metadata| { &m.authors },
                |m: &mut Metadata| { &mut m.authors },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Component>(
                "component",
                Metadata::has_component,
                Metadata::get_component,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OrganizationalEntity>(
                "manufacture",
                Metadata::has_manufacture,
                Metadata::get_manufacture,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OrganizationalEntity>(
                "supplier",
                Metadata::has_supplier,
                Metadata::get_supplier,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, LicenseChoice>(
                "licenses",
                Metadata::has_licenses,
                Metadata::get_licenses,
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Property>>(
                "properties",
                |m: &Metadata| { &m.properties },
                |m: &mut Metadata| { &mut m.properties },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Metadata>(
                "Metadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Metadata {
        static instance: ::protobuf::rt::LazyV2<Metadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Metadata::new)
    }
}

impl ::protobuf::Clear for Metadata {
    fn clear(&mut self) {
        self._timestamp = ::std::option::Option::None;
        self.tools.clear();
        self.authors.clear();
        self._component = ::std::option::Option::None;
        self._manufacture = ::std::option::Option::None;
        self._supplier = ::std::option::Option::None;
        self._licenses = ::std::option::Option::None;
        self.properties.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Metadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Metadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct OrganizationalContact {
    // message oneof groups
    pub _name: ::std::option::Option<OrganizationalContact_oneof__name>,
    pub _email: ::std::option::Option<OrganizationalContact_oneof__email>,
    pub _phone: ::std::option::Option<OrganizationalContact_oneof__phone>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OrganizationalContact {
    fn default() -> &'a OrganizationalContact {
        <OrganizationalContact as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum OrganizationalContact_oneof__name {
    name(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum OrganizationalContact_oneof__email {
    email(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum OrganizationalContact_oneof__phone {
    phone(::std::string::String),
}

impl OrganizationalContact {
    pub fn new() -> OrganizationalContact {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        match self._name {
            ::std::option::Option::Some(OrganizationalContact_oneof__name::name(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_name(&mut self) {
        self._name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        match self._name {
            ::std::option::Option::Some(OrganizationalContact_oneof__name::name(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self._name = ::std::option::Option::Some(OrganizationalContact_oneof__name::name(v))
    }

    // Mutable pointer to the field.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(OrganizationalContact_oneof__name::name(_)) = self._name {
        } else {
            self._name = ::std::option::Option::Some(OrganizationalContact_oneof__name::name(::std::string::String::new()));
        }
        match self._name {
            ::std::option::Option::Some(OrganizationalContact_oneof__name::name(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        if self.has_name() {
            match self._name.take() {
                ::std::option::Option::Some(OrganizationalContact_oneof__name::name(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string email = 2;


    pub fn get_email(&self) -> &str {
        match self._email {
            ::std::option::Option::Some(OrganizationalContact_oneof__email::email(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_email(&mut self) {
        self._email = ::std::option::Option::None;
    }

    pub fn has_email(&self) -> bool {
        match self._email {
            ::std::option::Option::Some(OrganizationalContact_oneof__email::email(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_email(&mut self, v: ::std::string::String) {
        self._email = ::std::option::Option::Some(OrganizationalContact_oneof__email::email(v))
    }

    // Mutable pointer to the field.
    pub fn mut_email(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(OrganizationalContact_oneof__email::email(_)) = self._email {
        } else {
            self._email = ::std::option::Option::Some(OrganizationalContact_oneof__email::email(::std::string::String::new()));
        }
        match self._email {
            ::std::option::Option::Some(OrganizationalContact_oneof__email::email(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_email(&mut self) -> ::std::string::String {
        if self.has_email() {
            match self._email.take() {
                ::std::option::Option::Some(OrganizationalContact_oneof__email::email(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string phone = 3;


    pub fn get_phone(&self) -> &str {
        match self._phone {
            ::std::option::Option::Some(OrganizationalContact_oneof__phone::phone(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_phone(&mut self) {
        self._phone = ::std::option::Option::None;
    }

    pub fn has_phone(&self) -> bool {
        match self._phone {
            ::std::option::Option::Some(OrganizationalContact_oneof__phone::phone(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_phone(&mut self, v: ::std::string::String) {
        self._phone = ::std::option::Option::Some(OrganizationalContact_oneof__phone::phone(v))
    }

    // Mutable pointer to the field.
    pub fn mut_phone(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(OrganizationalContact_oneof__phone::phone(_)) = self._phone {
        } else {
            self._phone = ::std::option::Option::Some(OrganizationalContact_oneof__phone::phone(::std::string::String::new()));
        }
        match self._phone {
            ::std::option::Option::Some(OrganizationalContact_oneof__phone::phone(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_phone(&mut self) -> ::std::string::String {
        if self.has_phone() {
            match self._phone.take() {
                ::std::option::Option::Some(OrganizationalContact_oneof__phone::phone(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for OrganizationalContact {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._name = ::std::option::Option::Some(OrganizationalContact_oneof__name::name(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._email = ::std::option::Option::Some(OrganizationalContact_oneof__email::email(is.read_string()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._phone = ::std::option::Option::Some(OrganizationalContact_oneof__phone::phone(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self._name {
            match v {
                &OrganizationalContact_oneof__name::name(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._email {
            match v {
                &OrganizationalContact_oneof__email::email(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._phone {
            match v {
                &OrganizationalContact_oneof__phone::phone(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self._name {
            match v {
                &OrganizationalContact_oneof__name::name(ref v) => {
                    os.write_string(1, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._email {
            match v {
                &OrganizationalContact_oneof__email::email(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._phone {
            match v {
                &OrganizationalContact_oneof__phone::phone(ref v) => {
                    os.write_string(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrganizationalContact {
        OrganizationalContact::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "name",
                OrganizationalContact::has_name,
                OrganizationalContact::get_name,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "email",
                OrganizationalContact::has_email,
                OrganizationalContact::get_email,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "phone",
                OrganizationalContact::has_phone,
                OrganizationalContact::get_phone,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OrganizationalContact>(
                "OrganizationalContact",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OrganizationalContact {
        static instance: ::protobuf::rt::LazyV2<OrganizationalContact> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OrganizationalContact::new)
    }
}

impl ::protobuf::Clear for OrganizationalContact {
    fn clear(&mut self) {
        self._name = ::std::option::Option::None;
        self._email = ::std::option::Option::None;
        self._phone = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OrganizationalContact {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OrganizationalContact {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct OrganizationalEntity {
    // message fields
    pub url: ::protobuf::RepeatedField<::std::string::String>,
    pub contact: ::protobuf::RepeatedField<OrganizationalContact>,
    // message oneof groups
    pub _name: ::std::option::Option<OrganizationalEntity_oneof__name>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OrganizationalEntity {
    fn default() -> &'a OrganizationalEntity {
        <OrganizationalEntity as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum OrganizationalEntity_oneof__name {
    name(::std::string::String),
}

impl OrganizationalEntity {
    pub fn new() -> OrganizationalEntity {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        match self._name {
            ::std::option::Option::Some(OrganizationalEntity_oneof__name::name(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_name(&mut self) {
        self._name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        match self._name {
            ::std::option::Option::Some(OrganizationalEntity_oneof__name::name(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self._name = ::std::option::Option::Some(OrganizationalEntity_oneof__name::name(v))
    }

    // Mutable pointer to the field.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(OrganizationalEntity_oneof__name::name(_)) = self._name {
        } else {
            self._name = ::std::option::Option::Some(OrganizationalEntity_oneof__name::name(::std::string::String::new()));
        }
        match self._name {
            ::std::option::Option::Some(OrganizationalEntity_oneof__name::name(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        if self.has_name() {
            match self._name.take() {
                ::std::option::Option::Some(OrganizationalEntity_oneof__name::name(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // repeated string url = 2;


    pub fn get_url(&self) -> &[::std::string::String] {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.url = v;
    }

    // Mutable pointer to the field.
    pub fn mut_url(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.url, ::protobuf::RepeatedField::new())
    }

    // repeated .cyclonedx.v1_3.OrganizationalContact contact = 3;


    pub fn get_contact(&self) -> &[OrganizationalContact] {
        &self.contact
    }
    pub fn clear_contact(&mut self) {
        self.contact.clear();
    }

    // Param is passed by value, moved
    pub fn set_contact(&mut self, v: ::protobuf::RepeatedField<OrganizationalContact>) {
        self.contact = v;
    }

    // Mutable pointer to the field.
    pub fn mut_contact(&mut self) -> &mut ::protobuf::RepeatedField<OrganizationalContact> {
        &mut self.contact
    }

    // Take field
    pub fn take_contact(&mut self) -> ::protobuf::RepeatedField<OrganizationalContact> {
        ::std::mem::replace(&mut self.contact, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for OrganizationalEntity {
    fn is_initialized(&self) -> bool {
        for v in &self.contact {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._name = ::std::option::Option::Some(OrganizationalEntity_oneof__name::name(is.read_string()?));
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.url)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.contact)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.url {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.contact {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let ::std::option::Option::Some(ref v) = self._name {
            match v {
                &OrganizationalEntity_oneof__name::name(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.url {
            os.write_string(2, &v)?;
        };
        for v in &self.contact {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let ::std::option::Option::Some(ref v) = self._name {
            match v {
                &OrganizationalEntity_oneof__name::name(ref v) => {
                    os.write_string(1, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrganizationalEntity {
        OrganizationalEntity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "name",
                OrganizationalEntity::has_name,
                OrganizationalEntity::get_name,
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &OrganizationalEntity| { &m.url },
                |m: &mut OrganizationalEntity| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OrganizationalContact>>(
                "contact",
                |m: &OrganizationalEntity| { &m.contact },
                |m: &mut OrganizationalEntity| { &mut m.contact },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OrganizationalEntity>(
                "OrganizationalEntity",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OrganizationalEntity {
        static instance: ::protobuf::rt::LazyV2<OrganizationalEntity> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OrganizationalEntity::new)
    }
}

impl ::protobuf::Clear for OrganizationalEntity {
    fn clear(&mut self) {
        self._name = ::std::option::Option::None;
        self.url.clear();
        self.contact.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OrganizationalEntity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OrganizationalEntity {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Patch {
    // message fields
    pub field_type: PatchClassification,
    pub resolves: ::protobuf::RepeatedField<Issue>,
    // message oneof groups
    pub _diff: ::std::option::Option<Patch_oneof__diff>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Patch {
    fn default() -> &'a Patch {
        <Patch as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Patch_oneof__diff {
    diff(Diff),
}

impl Patch {
    pub fn new() -> Patch {
        ::std::default::Default::default()
    }

    // .cyclonedx.v1_3.PatchClassification type = 1;


    pub fn get_field_type(&self) -> PatchClassification {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = PatchClassification::PATCH_CLASSIFICATION_NULL;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: PatchClassification) {
        self.field_type = v;
    }

    // .cyclonedx.v1_3.Diff diff = 2;


    pub fn get_diff(&self) -> &Diff {
        match self._diff {
            ::std::option::Option::Some(Patch_oneof__diff::diff(ref v)) => v,
            _ => <Diff as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_diff(&mut self) {
        self._diff = ::std::option::Option::None;
    }

    pub fn has_diff(&self) -> bool {
        match self._diff {
            ::std::option::Option::Some(Patch_oneof__diff::diff(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_diff(&mut self, v: Diff) {
        self._diff = ::std::option::Option::Some(Patch_oneof__diff::diff(v))
    }

    // Mutable pointer to the field.
    pub fn mut_diff(&mut self) -> &mut Diff {
        if let ::std::option::Option::Some(Patch_oneof__diff::diff(_)) = self._diff {
        } else {
            self._diff = ::std::option::Option::Some(Patch_oneof__diff::diff(Diff::new()));
        }
        match self._diff {
            ::std::option::Option::Some(Patch_oneof__diff::diff(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_diff(&mut self) -> Diff {
        if self.has_diff() {
            match self._diff.take() {
                ::std::option::Option::Some(Patch_oneof__diff::diff(v)) => v,
                _ => panic!(),
            }
        } else {
            Diff::new()
        }
    }

    // repeated .cyclonedx.v1_3.Issue resolves = 3;


    pub fn get_resolves(&self) -> &[Issue] {
        &self.resolves
    }
    pub fn clear_resolves(&mut self) {
        self.resolves.clear();
    }

    // Param is passed by value, moved
    pub fn set_resolves(&mut self, v: ::protobuf::RepeatedField<Issue>) {
        self.resolves = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resolves(&mut self) -> &mut ::protobuf::RepeatedField<Issue> {
        &mut self.resolves
    }

    // Take field
    pub fn take_resolves(&mut self) -> ::protobuf::RepeatedField<Issue> {
        ::std::mem::replace(&mut self.resolves, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Patch {
    fn is_initialized(&self) -> bool {
        if let Some(Patch_oneof__diff::diff(ref v)) = self._diff {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.resolves {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._diff = ::std::option::Option::Some(Patch_oneof__diff::diff(is.read_message()?));
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resolves)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != PatchClassification::PATCH_CLASSIFICATION_NULL {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        for value in &self.resolves {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let ::std::option::Option::Some(ref v) = self._diff {
            match v {
                &Patch_oneof__diff::diff(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != PatchClassification::PATCH_CLASSIFICATION_NULL {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        for v in &self.resolves {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let ::std::option::Option::Some(ref v) = self._diff {
            match v {
                &Patch_oneof__diff::diff(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Patch {
        Patch::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PatchClassification>>(
                "type",
                |m: &Patch| { &m.field_type },
                |m: &mut Patch| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Diff>(
                "diff",
                Patch::has_diff,
                Patch::get_diff,
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Issue>>(
                "resolves",
                |m: &Patch| { &m.resolves },
                |m: &mut Patch| { &mut m.resolves },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Patch>(
                "Patch",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Patch {
        static instance: ::protobuf::rt::LazyV2<Patch> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Patch::new)
    }
}

impl ::protobuf::Clear for Patch {
    fn clear(&mut self) {
        self.field_type = PatchClassification::PATCH_CLASSIFICATION_NULL;
        self._diff = ::std::option::Option::None;
        self.resolves.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Patch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Patch {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Pedigree {
    // message fields
    pub ancestors: ::protobuf::RepeatedField<Component>,
    pub descendants: ::protobuf::RepeatedField<Component>,
    pub variants: ::protobuf::RepeatedField<Component>,
    pub commits: ::protobuf::RepeatedField<Commit>,
    pub patches: ::protobuf::RepeatedField<Patch>,
    // message oneof groups
    pub _notes: ::std::option::Option<Pedigree_oneof__notes>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Pedigree {
    fn default() -> &'a Pedigree {
        <Pedigree as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Pedigree_oneof__notes {
    notes(::std::string::String),
}

impl Pedigree {
    pub fn new() -> Pedigree {
        ::std::default::Default::default()
    }

    // repeated .cyclonedx.v1_3.Component ancestors = 1;


    pub fn get_ancestors(&self) -> &[Component] {
        &self.ancestors
    }
    pub fn clear_ancestors(&mut self) {
        self.ancestors.clear();
    }

    // Param is passed by value, moved
    pub fn set_ancestors(&mut self, v: ::protobuf::RepeatedField<Component>) {
        self.ancestors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ancestors(&mut self) -> &mut ::protobuf::RepeatedField<Component> {
        &mut self.ancestors
    }

    // Take field
    pub fn take_ancestors(&mut self) -> ::protobuf::RepeatedField<Component> {
        ::std::mem::replace(&mut self.ancestors, ::protobuf::RepeatedField::new())
    }

    // repeated .cyclonedx.v1_3.Component descendants = 2;


    pub fn get_descendants(&self) -> &[Component] {
        &self.descendants
    }
    pub fn clear_descendants(&mut self) {
        self.descendants.clear();
    }

    // Param is passed by value, moved
    pub fn set_descendants(&mut self, v: ::protobuf::RepeatedField<Component>) {
        self.descendants = v;
    }

    // Mutable pointer to the field.
    pub fn mut_descendants(&mut self) -> &mut ::protobuf::RepeatedField<Component> {
        &mut self.descendants
    }

    // Take field
    pub fn take_descendants(&mut self) -> ::protobuf::RepeatedField<Component> {
        ::std::mem::replace(&mut self.descendants, ::protobuf::RepeatedField::new())
    }

    // repeated .cyclonedx.v1_3.Component variants = 3;


    pub fn get_variants(&self) -> &[Component] {
        &self.variants
    }
    pub fn clear_variants(&mut self) {
        self.variants.clear();
    }

    // Param is passed by value, moved
    pub fn set_variants(&mut self, v: ::protobuf::RepeatedField<Component>) {
        self.variants = v;
    }

    // Mutable pointer to the field.
    pub fn mut_variants(&mut self) -> &mut ::protobuf::RepeatedField<Component> {
        &mut self.variants
    }

    // Take field
    pub fn take_variants(&mut self) -> ::protobuf::RepeatedField<Component> {
        ::std::mem::replace(&mut self.variants, ::protobuf::RepeatedField::new())
    }

    // repeated .cyclonedx.v1_3.Commit commits = 4;


    pub fn get_commits(&self) -> &[Commit] {
        &self.commits
    }
    pub fn clear_commits(&mut self) {
        self.commits.clear();
    }

    // Param is passed by value, moved
    pub fn set_commits(&mut self, v: ::protobuf::RepeatedField<Commit>) {
        self.commits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_commits(&mut self) -> &mut ::protobuf::RepeatedField<Commit> {
        &mut self.commits
    }

    // Take field
    pub fn take_commits(&mut self) -> ::protobuf::RepeatedField<Commit> {
        ::std::mem::replace(&mut self.commits, ::protobuf::RepeatedField::new())
    }

    // repeated .cyclonedx.v1_3.Patch patches = 5;


    pub fn get_patches(&self) -> &[Patch] {
        &self.patches
    }
    pub fn clear_patches(&mut self) {
        self.patches.clear();
    }

    // Param is passed by value, moved
    pub fn set_patches(&mut self, v: ::protobuf::RepeatedField<Patch>) {
        self.patches = v;
    }

    // Mutable pointer to the field.
    pub fn mut_patches(&mut self) -> &mut ::protobuf::RepeatedField<Patch> {
        &mut self.patches
    }

    // Take field
    pub fn take_patches(&mut self) -> ::protobuf::RepeatedField<Patch> {
        ::std::mem::replace(&mut self.patches, ::protobuf::RepeatedField::new())
    }

    // string notes = 6;


    pub fn get_notes(&self) -> &str {
        match self._notes {
            ::std::option::Option::Some(Pedigree_oneof__notes::notes(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_notes(&mut self) {
        self._notes = ::std::option::Option::None;
    }

    pub fn has_notes(&self) -> bool {
        match self._notes {
            ::std::option::Option::Some(Pedigree_oneof__notes::notes(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_notes(&mut self, v: ::std::string::String) {
        self._notes = ::std::option::Option::Some(Pedigree_oneof__notes::notes(v))
    }

    // Mutable pointer to the field.
    pub fn mut_notes(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Pedigree_oneof__notes::notes(_)) = self._notes {
        } else {
            self._notes = ::std::option::Option::Some(Pedigree_oneof__notes::notes(::std::string::String::new()));
        }
        match self._notes {
            ::std::option::Option::Some(Pedigree_oneof__notes::notes(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_notes(&mut self) -> ::std::string::String {
        if self.has_notes() {
            match self._notes.take() {
                ::std::option::Option::Some(Pedigree_oneof__notes::notes(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for Pedigree {
    fn is_initialized(&self) -> bool {
        for v in &self.ancestors {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.descendants {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.variants {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.commits {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.patches {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ancestors)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.descendants)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.variants)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.commits)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.patches)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._notes = ::std::option::Option::Some(Pedigree_oneof__notes::notes(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ancestors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.descendants {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.variants {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.commits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.patches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let ::std::option::Option::Some(ref v) = self._notes {
            match v {
                &Pedigree_oneof__notes::notes(ref v) => {
                    my_size += ::protobuf::rt::string_size(6, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ancestors {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.descendants {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.variants {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.commits {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.patches {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let ::std::option::Option::Some(ref v) = self._notes {
            match v {
                &Pedigree_oneof__notes::notes(ref v) => {
                    os.write_string(6, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Pedigree {
        Pedigree::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Component>>(
                "ancestors",
                |m: &Pedigree| { &m.ancestors },
                |m: &mut Pedigree| { &mut m.ancestors },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Component>>(
                "descendants",
                |m: &Pedigree| { &m.descendants },
                |m: &mut Pedigree| { &mut m.descendants },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Component>>(
                "variants",
                |m: &Pedigree| { &m.variants },
                |m: &mut Pedigree| { &mut m.variants },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Commit>>(
                "commits",
                |m: &Pedigree| { &m.commits },
                |m: &mut Pedigree| { &mut m.commits },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Patch>>(
                "patches",
                |m: &Pedigree| { &m.patches },
                |m: &mut Pedigree| { &mut m.patches },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "notes",
                Pedigree::has_notes,
                Pedigree::get_notes,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Pedigree>(
                "Pedigree",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Pedigree {
        static instance: ::protobuf::rt::LazyV2<Pedigree> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Pedigree::new)
    }
}

impl ::protobuf::Clear for Pedigree {
    fn clear(&mut self) {
        self.ancestors.clear();
        self.descendants.clear();
        self.variants.clear();
        self.commits.clear();
        self.patches.clear();
        self._notes = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Pedigree {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pedigree {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Service {
    // message fields
    pub name: ::std::string::String,
    pub endpoints: ::protobuf::RepeatedField<::std::string::String>,
    pub data: ::protobuf::RepeatedField<DataClassification>,
    pub licenses: ::protobuf::RepeatedField<LicenseChoice>,
    pub external_references: ::protobuf::RepeatedField<ExternalReference>,
    pub services: ::protobuf::RepeatedField<Service>,
    pub properties: ::protobuf::RepeatedField<Property>,
    // message oneof groups
    pub _bom_ref: ::std::option::Option<Service_oneof__bom_ref>,
    pub _provider: ::std::option::Option<Service_oneof__provider>,
    pub _group: ::std::option::Option<Service_oneof__group>,
    pub _version: ::std::option::Option<Service_oneof__version>,
    pub _description: ::std::option::Option<Service_oneof__description>,
    pub _authenticated: ::std::option::Option<Service_oneof__authenticated>,
    pub _x_trust_boundary: ::std::option::Option<Service_oneof__x_trust_boundary>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Service {
    fn default() -> &'a Service {
        <Service as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Service_oneof__bom_ref {
    bom_ref(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Service_oneof__provider {
    provider(OrganizationalEntity),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Service_oneof__group {
    group(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Service_oneof__version {
    version(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Service_oneof__description {
    description(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Service_oneof__authenticated {
    authenticated(bool),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Service_oneof__x_trust_boundary {
    x_trust_boundary(bool),
}

impl Service {
    pub fn new() -> Service {
        ::std::default::Default::default()
    }

    // string bom_ref = 1;


    pub fn get_bom_ref(&self) -> &str {
        match self._bom_ref {
            ::std::option::Option::Some(Service_oneof__bom_ref::bom_ref(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_bom_ref(&mut self) {
        self._bom_ref = ::std::option::Option::None;
    }

    pub fn has_bom_ref(&self) -> bool {
        match self._bom_ref {
            ::std::option::Option::Some(Service_oneof__bom_ref::bom_ref(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bom_ref(&mut self, v: ::std::string::String) {
        self._bom_ref = ::std::option::Option::Some(Service_oneof__bom_ref::bom_ref(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bom_ref(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Service_oneof__bom_ref::bom_ref(_)) = self._bom_ref {
        } else {
            self._bom_ref = ::std::option::Option::Some(Service_oneof__bom_ref::bom_ref(::std::string::String::new()));
        }
        match self._bom_ref {
            ::std::option::Option::Some(Service_oneof__bom_ref::bom_ref(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bom_ref(&mut self) -> ::std::string::String {
        if self.has_bom_ref() {
            match self._bom_ref.take() {
                ::std::option::Option::Some(Service_oneof__bom_ref::bom_ref(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .cyclonedx.v1_3.OrganizationalEntity provider = 2;


    pub fn get_provider(&self) -> &OrganizationalEntity {
        match self._provider {
            ::std::option::Option::Some(Service_oneof__provider::provider(ref v)) => v,
            _ => <OrganizationalEntity as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_provider(&mut self) {
        self._provider = ::std::option::Option::None;
    }

    pub fn has_provider(&self) -> bool {
        match self._provider {
            ::std::option::Option::Some(Service_oneof__provider::provider(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_provider(&mut self, v: OrganizationalEntity) {
        self._provider = ::std::option::Option::Some(Service_oneof__provider::provider(v))
    }

    // Mutable pointer to the field.
    pub fn mut_provider(&mut self) -> &mut OrganizationalEntity {
        if let ::std::option::Option::Some(Service_oneof__provider::provider(_)) = self._provider {
        } else {
            self._provider = ::std::option::Option::Some(Service_oneof__provider::provider(OrganizationalEntity::new()));
        }
        match self._provider {
            ::std::option::Option::Some(Service_oneof__provider::provider(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_provider(&mut self) -> OrganizationalEntity {
        if self.has_provider() {
            match self._provider.take() {
                ::std::option::Option::Some(Service_oneof__provider::provider(v)) => v,
                _ => panic!(),
            }
        } else {
            OrganizationalEntity::new()
        }
    }

    // string group = 3;


    pub fn get_group(&self) -> &str {
        match self._group {
            ::std::option::Option::Some(Service_oneof__group::group(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_group(&mut self) {
        self._group = ::std::option::Option::None;
    }

    pub fn has_group(&self) -> bool {
        match self._group {
            ::std::option::Option::Some(Service_oneof__group::group(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::std::string::String) {
        self._group = ::std::option::Option::Some(Service_oneof__group::group(v))
    }

    // Mutable pointer to the field.
    pub fn mut_group(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Service_oneof__group::group(_)) = self._group {
        } else {
            self._group = ::std::option::Option::Some(Service_oneof__group::group(::std::string::String::new()));
        }
        match self._group {
            ::std::option::Option::Some(Service_oneof__group::group(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_group(&mut self) -> ::std::string::String {
        if self.has_group() {
            match self._group.take() {
                ::std::option::Option::Some(Service_oneof__group::group(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string name = 4;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string version = 5;


    pub fn get_version(&self) -> &str {
        match self._version {
            ::std::option::Option::Some(Service_oneof__version::version(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_version(&mut self) {
        self._version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        match self._version {
            ::std::option::Option::Some(Service_oneof__version::version(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self._version = ::std::option::Option::Some(Service_oneof__version::version(v))
    }

    // Mutable pointer to the field.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Service_oneof__version::version(_)) = self._version {
        } else {
            self._version = ::std::option::Option::Some(Service_oneof__version::version(::std::string::String::new()));
        }
        match self._version {
            ::std::option::Option::Some(Service_oneof__version::version(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        if self.has_version() {
            match self._version.take() {
                ::std::option::Option::Some(Service_oneof__version::version(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string description = 6;


    pub fn get_description(&self) -> &str {
        match self._description {
            ::std::option::Option::Some(Service_oneof__description::description(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_description(&mut self) {
        self._description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        match self._description {
            ::std::option::Option::Some(Service_oneof__description::description(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self._description = ::std::option::Option::Some(Service_oneof__description::description(v))
    }

    // Mutable pointer to the field.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Service_oneof__description::description(_)) = self._description {
        } else {
            self._description = ::std::option::Option::Some(Service_oneof__description::description(::std::string::String::new()));
        }
        match self._description {
            ::std::option::Option::Some(Service_oneof__description::description(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        if self.has_description() {
            match self._description.take() {
                ::std::option::Option::Some(Service_oneof__description::description(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // repeated string endpoints = 7;


    pub fn get_endpoints(&self) -> &[::std::string::String] {
        &self.endpoints
    }
    pub fn clear_endpoints(&mut self) {
        self.endpoints.clear();
    }

    // Param is passed by value, moved
    pub fn set_endpoints(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.endpoints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_endpoints(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.endpoints
    }

    // Take field
    pub fn take_endpoints(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.endpoints, ::protobuf::RepeatedField::new())
    }

    // bool authenticated = 8;


    pub fn get_authenticated(&self) -> bool {
        match self._authenticated {
            ::std::option::Option::Some(Service_oneof__authenticated::authenticated(v)) => v,
            _ => false,
        }
    }
    pub fn clear_authenticated(&mut self) {
        self._authenticated = ::std::option::Option::None;
    }

    pub fn has_authenticated(&self) -> bool {
        match self._authenticated {
            ::std::option::Option::Some(Service_oneof__authenticated::authenticated(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_authenticated(&mut self, v: bool) {
        self._authenticated = ::std::option::Option::Some(Service_oneof__authenticated::authenticated(v))
    }

    // bool x_trust_boundary = 9;


    pub fn get_x_trust_boundary(&self) -> bool {
        match self._x_trust_boundary {
            ::std::option::Option::Some(Service_oneof__x_trust_boundary::x_trust_boundary(v)) => v,
            _ => false,
        }
    }
    pub fn clear_x_trust_boundary(&mut self) {
        self._x_trust_boundary = ::std::option::Option::None;
    }

    pub fn has_x_trust_boundary(&self) -> bool {
        match self._x_trust_boundary {
            ::std::option::Option::Some(Service_oneof__x_trust_boundary::x_trust_boundary(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_x_trust_boundary(&mut self, v: bool) {
        self._x_trust_boundary = ::std::option::Option::Some(Service_oneof__x_trust_boundary::x_trust_boundary(v))
    }

    // repeated .cyclonedx.v1_3.DataClassification data = 10;


    pub fn get_data(&self) -> &[DataClassification] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::protobuf::RepeatedField<DataClassification>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::protobuf::RepeatedField<DataClassification> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::protobuf::RepeatedField<DataClassification> {
        ::std::mem::replace(&mut self.data, ::protobuf::RepeatedField::new())
    }

    // repeated .cyclonedx.v1_3.LicenseChoice licenses = 11;


    pub fn get_licenses(&self) -> &[LicenseChoice] {
        &self.licenses
    }
    pub fn clear_licenses(&mut self) {
        self.licenses.clear();
    }

    // Param is passed by value, moved
    pub fn set_licenses(&mut self, v: ::protobuf::RepeatedField<LicenseChoice>) {
        self.licenses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_licenses(&mut self) -> &mut ::protobuf::RepeatedField<LicenseChoice> {
        &mut self.licenses
    }

    // Take field
    pub fn take_licenses(&mut self) -> ::protobuf::RepeatedField<LicenseChoice> {
        ::std::mem::replace(&mut self.licenses, ::protobuf::RepeatedField::new())
    }

    // repeated .cyclonedx.v1_3.ExternalReference external_references = 12;


    pub fn get_external_references(&self) -> &[ExternalReference] {
        &self.external_references
    }
    pub fn clear_external_references(&mut self) {
        self.external_references.clear();
    }

    // Param is passed by value, moved
    pub fn set_external_references(&mut self, v: ::protobuf::RepeatedField<ExternalReference>) {
        self.external_references = v;
    }

    // Mutable pointer to the field.
    pub fn mut_external_references(&mut self) -> &mut ::protobuf::RepeatedField<ExternalReference> {
        &mut self.external_references
    }

    // Take field
    pub fn take_external_references(&mut self) -> ::protobuf::RepeatedField<ExternalReference> {
        ::std::mem::replace(&mut self.external_references, ::protobuf::RepeatedField::new())
    }

    // repeated .cyclonedx.v1_3.Service services = 13;


    pub fn get_services(&self) -> &[Service] {
        &self.services
    }
    pub fn clear_services(&mut self) {
        self.services.clear();
    }

    // Param is passed by value, moved
    pub fn set_services(&mut self, v: ::protobuf::RepeatedField<Service>) {
        self.services = v;
    }

    // Mutable pointer to the field.
    pub fn mut_services(&mut self) -> &mut ::protobuf::RepeatedField<Service> {
        &mut self.services
    }

    // Take field
    pub fn take_services(&mut self) -> ::protobuf::RepeatedField<Service> {
        ::std::mem::replace(&mut self.services, ::protobuf::RepeatedField::new())
    }

    // repeated .cyclonedx.v1_3.Property properties = 14;


    pub fn get_properties(&self) -> &[Property] {
        &self.properties
    }
    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::protobuf::RepeatedField<Property>) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properties(&mut self) -> &mut ::protobuf::RepeatedField<Property> {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::protobuf::RepeatedField<Property> {
        ::std::mem::replace(&mut self.properties, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Service {
    fn is_initialized(&self) -> bool {
        if let Some(Service_oneof__provider::provider(ref v)) = self._provider {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.licenses {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.external_references {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.services {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.properties {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._bom_ref = ::std::option::Option::Some(Service_oneof__bom_ref::bom_ref(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._provider = ::std::option::Option::Some(Service_oneof__provider::provider(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._group = ::std::option::Option::Some(Service_oneof__group::group(is.read_string()?));
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._version = ::std::option::Option::Some(Service_oneof__version::version(is.read_string()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._description = ::std::option::Option::Some(Service_oneof__description::description(is.read_string()?));
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.endpoints)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._authenticated = ::std::option::Option::Some(Service_oneof__authenticated::authenticated(is.read_bool()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._x_trust_boundary = ::std::option::Option::Some(Service_oneof__x_trust_boundary::x_trust_boundary(is.read_bool()?));
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.licenses)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.external_references)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.services)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.properties)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.name);
        }
        for value in &self.endpoints {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.licenses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.external_references {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.services {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let ::std::option::Option::Some(ref v) = self._bom_ref {
            match v {
                &Service_oneof__bom_ref::bom_ref(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._provider {
            match v {
                &Service_oneof__provider::provider(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._group {
            match v {
                &Service_oneof__group::group(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._version {
            match v {
                &Service_oneof__version::version(ref v) => {
                    my_size += ::protobuf::rt::string_size(5, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._description {
            match v {
                &Service_oneof__description::description(ref v) => {
                    my_size += ::protobuf::rt::string_size(6, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._authenticated {
            match v {
                &Service_oneof__authenticated::authenticated(v) => {
                    my_size += 2;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._x_trust_boundary {
            match v {
                &Service_oneof__x_trust_boundary::x_trust_boundary(v) => {
                    my_size += 2;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(4, &self.name)?;
        }
        for v in &self.endpoints {
            os.write_string(7, &v)?;
        };
        for v in &self.data {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.licenses {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.external_references {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.services {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.properties {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let ::std::option::Option::Some(ref v) = self._bom_ref {
            match v {
                &Service_oneof__bom_ref::bom_ref(ref v) => {
                    os.write_string(1, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._provider {
            match v {
                &Service_oneof__provider::provider(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._group {
            match v {
                &Service_oneof__group::group(ref v) => {
                    os.write_string(3, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._version {
            match v {
                &Service_oneof__version::version(ref v) => {
                    os.write_string(5, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._description {
            match v {
                &Service_oneof__description::description(ref v) => {
                    os.write_string(6, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._authenticated {
            match v {
                &Service_oneof__authenticated::authenticated(v) => {
                    os.write_bool(8, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._x_trust_boundary {
            match v {
                &Service_oneof__x_trust_boundary::x_trust_boundary(v) => {
                    os.write_bool(9, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Service {
        Service::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "bom_ref",
                Service::has_bom_ref,
                Service::get_bom_ref,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OrganizationalEntity>(
                "provider",
                Service::has_provider,
                Service::get_provider,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "group",
                Service::has_group,
                Service::get_group,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Service| { &m.name },
                |m: &mut Service| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "version",
                Service::has_version,
                Service::get_version,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "description",
                Service::has_description,
                Service::get_description,
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "endpoints",
                |m: &Service| { &m.endpoints },
                |m: &mut Service| { &mut m.endpoints },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "authenticated",
                Service::has_authenticated,
                Service::get_authenticated,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "x_trust_boundary",
                Service::has_x_trust_boundary,
                Service::get_x_trust_boundary,
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataClassification>>(
                "data",
                |m: &Service| { &m.data },
                |m: &mut Service| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LicenseChoice>>(
                "licenses",
                |m: &Service| { &m.licenses },
                |m: &mut Service| { &mut m.licenses },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalReference>>(
                "external_references",
                |m: &Service| { &m.external_references },
                |m: &mut Service| { &mut m.external_references },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Service>>(
                "services",
                |m: &Service| { &m.services },
                |m: &mut Service| { &mut m.services },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Property>>(
                "properties",
                |m: &Service| { &m.properties },
                |m: &mut Service| { &mut m.properties },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Service>(
                "Service",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Service {
        static instance: ::protobuf::rt::LazyV2<Service> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Service::new)
    }
}

impl ::protobuf::Clear for Service {
    fn clear(&mut self) {
        self._bom_ref = ::std::option::Option::None;
        self._provider = ::std::option::Option::None;
        self._group = ::std::option::Option::None;
        self.name.clear();
        self._version = ::std::option::Option::None;
        self._description = ::std::option::Option::None;
        self.endpoints.clear();
        self._authenticated = ::std::option::Option::None;
        self._x_trust_boundary = ::std::option::Option::None;
        self.data.clear();
        self.licenses.clear();
        self.external_references.clear();
        self.services.clear();
        self.properties.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Service {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Service {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Swid {
    // message fields
    pub tag_id: ::std::string::String,
    pub name: ::std::string::String,
    // message oneof groups
    pub _version: ::std::option::Option<Swid_oneof__version>,
    pub _tag_version: ::std::option::Option<Swid_oneof__tag_version>,
    pub _patch: ::std::option::Option<Swid_oneof__patch>,
    pub _text: ::std::option::Option<Swid_oneof__text>,
    pub _url: ::std::option::Option<Swid_oneof__url>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Swid {
    fn default() -> &'a Swid {
        <Swid as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Swid_oneof__version {
    version(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Swid_oneof__tag_version {
    tag_version(i32),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Swid_oneof__patch {
    patch(bool),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Swid_oneof__text {
    text(AttachedText),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Swid_oneof__url {
    url(::std::string::String),
}

impl Swid {
    pub fn new() -> Swid {
        ::std::default::Default::default()
    }

    // string tag_id = 1;


    pub fn get_tag_id(&self) -> &str {
        &self.tag_id
    }
    pub fn clear_tag_id(&mut self) {
        self.tag_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_tag_id(&mut self, v: ::std::string::String) {
        self.tag_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tag_id(&mut self) -> &mut ::std::string::String {
        &mut self.tag_id
    }

    // Take field
    pub fn take_tag_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tag_id, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string version = 3;


    pub fn get_version(&self) -> &str {
        match self._version {
            ::std::option::Option::Some(Swid_oneof__version::version(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_version(&mut self) {
        self._version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        match self._version {
            ::std::option::Option::Some(Swid_oneof__version::version(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self._version = ::std::option::Option::Some(Swid_oneof__version::version(v))
    }

    // Mutable pointer to the field.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Swid_oneof__version::version(_)) = self._version {
        } else {
            self._version = ::std::option::Option::Some(Swid_oneof__version::version(::std::string::String::new()));
        }
        match self._version {
            ::std::option::Option::Some(Swid_oneof__version::version(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        if self.has_version() {
            match self._version.take() {
                ::std::option::Option::Some(Swid_oneof__version::version(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // int32 tag_version = 4;


    pub fn get_tag_version(&self) -> i32 {
        match self._tag_version {
            ::std::option::Option::Some(Swid_oneof__tag_version::tag_version(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_tag_version(&mut self) {
        self._tag_version = ::std::option::Option::None;
    }

    pub fn has_tag_version(&self) -> bool {
        match self._tag_version {
            ::std::option::Option::Some(Swid_oneof__tag_version::tag_version(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_tag_version(&mut self, v: i32) {
        self._tag_version = ::std::option::Option::Some(Swid_oneof__tag_version::tag_version(v))
    }

    // bool patch = 5;


    pub fn get_patch(&self) -> bool {
        match self._patch {
            ::std::option::Option::Some(Swid_oneof__patch::patch(v)) => v,
            _ => false,
        }
    }
    pub fn clear_patch(&mut self) {
        self._patch = ::std::option::Option::None;
    }

    pub fn has_patch(&self) -> bool {
        match self._patch {
            ::std::option::Option::Some(Swid_oneof__patch::patch(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_patch(&mut self, v: bool) {
        self._patch = ::std::option::Option::Some(Swid_oneof__patch::patch(v))
    }

    // .cyclonedx.v1_3.AttachedText text = 6;


    pub fn get_text(&self) -> &AttachedText {
        match self._text {
            ::std::option::Option::Some(Swid_oneof__text::text(ref v)) => v,
            _ => <AttachedText as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_text(&mut self) {
        self._text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        match self._text {
            ::std::option::Option::Some(Swid_oneof__text::text(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: AttachedText) {
        self._text = ::std::option::Option::Some(Swid_oneof__text::text(v))
    }

    // Mutable pointer to the field.
    pub fn mut_text(&mut self) -> &mut AttachedText {
        if let ::std::option::Option::Some(Swid_oneof__text::text(_)) = self._text {
        } else {
            self._text = ::std::option::Option::Some(Swid_oneof__text::text(AttachedText::new()));
        }
        match self._text {
            ::std::option::Option::Some(Swid_oneof__text::text(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_text(&mut self) -> AttachedText {
        if self.has_text() {
            match self._text.take() {
                ::std::option::Option::Some(Swid_oneof__text::text(v)) => v,
                _ => panic!(),
            }
        } else {
            AttachedText::new()
        }
    }

    // string url = 7;


    pub fn get_url(&self) -> &str {
        match self._url {
            ::std::option::Option::Some(Swid_oneof__url::url(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_url(&mut self) {
        self._url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        match self._url {
            ::std::option::Option::Some(Swid_oneof__url::url(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self._url = ::std::option::Option::Some(Swid_oneof__url::url(v))
    }

    // Mutable pointer to the field.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Swid_oneof__url::url(_)) = self._url {
        } else {
            self._url = ::std::option::Option::Some(Swid_oneof__url::url(::std::string::String::new()));
        }
        match self._url {
            ::std::option::Option::Some(Swid_oneof__url::url(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        if self.has_url() {
            match self._url.take() {
                ::std::option::Option::Some(Swid_oneof__url::url(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for Swid {
    fn is_initialized(&self) -> bool {
        if let Some(Swid_oneof__text::text(ref v)) = self._text {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tag_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._version = ::std::option::Option::Some(Swid_oneof__version::version(is.read_string()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._tag_version = ::std::option::Option::Some(Swid_oneof__tag_version::tag_version(is.read_int32()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._patch = ::std::option::Option::Some(Swid_oneof__patch::patch(is.read_bool()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._text = ::std::option::Option::Some(Swid_oneof__text::text(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._url = ::std::option::Option::Some(Swid_oneof__url::url(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.tag_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.tag_id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if let ::std::option::Option::Some(ref v) = self._version {
            match v {
                &Swid_oneof__version::version(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._tag_version {
            match v {
                &Swid_oneof__tag_version::tag_version(v) => {
                    my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._patch {
            match v {
                &Swid_oneof__patch::patch(v) => {
                    my_size += 2;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._text {
            match v {
                &Swid_oneof__text::text(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._url {
            match v {
                &Swid_oneof__url::url(ref v) => {
                    my_size += ::protobuf::rt::string_size(7, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.tag_id.is_empty() {
            os.write_string(1, &self.tag_id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if let ::std::option::Option::Some(ref v) = self._version {
            match v {
                &Swid_oneof__version::version(ref v) => {
                    os.write_string(3, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._tag_version {
            match v {
                &Swid_oneof__tag_version::tag_version(v) => {
                    os.write_int32(4, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._patch {
            match v {
                &Swid_oneof__patch::patch(v) => {
                    os.write_bool(5, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._text {
            match v {
                &Swid_oneof__text::text(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._url {
            match v {
                &Swid_oneof__url::url(ref v) => {
                    os.write_string(7, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Swid {
        Swid::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tag_id",
                |m: &Swid| { &m.tag_id },
                |m: &mut Swid| { &mut m.tag_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Swid| { &m.name },
                |m: &mut Swid| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "version",
                Swid::has_version,
                Swid::get_version,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor::<_>(
                "tag_version",
                Swid::has_tag_version,
                Swid::get_tag_version,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "patch",
                Swid::has_patch,
                Swid::get_patch,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AttachedText>(
                "text",
                Swid::has_text,
                Swid::get_text,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "url",
                Swid::has_url,
                Swid::get_url,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Swid>(
                "Swid",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Swid {
        static instance: ::protobuf::rt::LazyV2<Swid> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Swid::new)
    }
}

impl ::protobuf::Clear for Swid {
    fn clear(&mut self) {
        self.tag_id.clear();
        self.name.clear();
        self._version = ::std::option::Option::None;
        self._tag_version = ::std::option::Option::None;
        self._patch = ::std::option::Option::None;
        self._text = ::std::option::Option::None;
        self._url = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Swid {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Swid {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Tool {
    // message fields
    pub hashes: ::protobuf::RepeatedField<Hash>,
    // message oneof groups
    pub _vendor: ::std::option::Option<Tool_oneof__vendor>,
    pub _name: ::std::option::Option<Tool_oneof__name>,
    pub _version: ::std::option::Option<Tool_oneof__version>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Tool {
    fn default() -> &'a Tool {
        <Tool as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Tool_oneof__vendor {
    vendor(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Tool_oneof__name {
    name(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Tool_oneof__version {
    version(::std::string::String),
}

impl Tool {
    pub fn new() -> Tool {
        ::std::default::Default::default()
    }

    // string vendor = 1;


    pub fn get_vendor(&self) -> &str {
        match self._vendor {
            ::std::option::Option::Some(Tool_oneof__vendor::vendor(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_vendor(&mut self) {
        self._vendor = ::std::option::Option::None;
    }

    pub fn has_vendor(&self) -> bool {
        match self._vendor {
            ::std::option::Option::Some(Tool_oneof__vendor::vendor(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_vendor(&mut self, v: ::std::string::String) {
        self._vendor = ::std::option::Option::Some(Tool_oneof__vendor::vendor(v))
    }

    // Mutable pointer to the field.
    pub fn mut_vendor(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Tool_oneof__vendor::vendor(_)) = self._vendor {
        } else {
            self._vendor = ::std::option::Option::Some(Tool_oneof__vendor::vendor(::std::string::String::new()));
        }
        match self._vendor {
            ::std::option::Option::Some(Tool_oneof__vendor::vendor(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_vendor(&mut self) -> ::std::string::String {
        if self.has_vendor() {
            match self._vendor.take() {
                ::std::option::Option::Some(Tool_oneof__vendor::vendor(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        match self._name {
            ::std::option::Option::Some(Tool_oneof__name::name(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_name(&mut self) {
        self._name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        match self._name {
            ::std::option::Option::Some(Tool_oneof__name::name(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self._name = ::std::option::Option::Some(Tool_oneof__name::name(v))
    }

    // Mutable pointer to the field.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Tool_oneof__name::name(_)) = self._name {
        } else {
            self._name = ::std::option::Option::Some(Tool_oneof__name::name(::std::string::String::new()));
        }
        match self._name {
            ::std::option::Option::Some(Tool_oneof__name::name(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        if self.has_name() {
            match self._name.take() {
                ::std::option::Option::Some(Tool_oneof__name::name(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string version = 3;


    pub fn get_version(&self) -> &str {
        match self._version {
            ::std::option::Option::Some(Tool_oneof__version::version(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_version(&mut self) {
        self._version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        match self._version {
            ::std::option::Option::Some(Tool_oneof__version::version(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self._version = ::std::option::Option::Some(Tool_oneof__version::version(v))
    }

    // Mutable pointer to the field.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Tool_oneof__version::version(_)) = self._version {
        } else {
            self._version = ::std::option::Option::Some(Tool_oneof__version::version(::std::string::String::new()));
        }
        match self._version {
            ::std::option::Option::Some(Tool_oneof__version::version(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        if self.has_version() {
            match self._version.take() {
                ::std::option::Option::Some(Tool_oneof__version::version(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // repeated .cyclonedx.v1_3.Hash hashes = 4;


    pub fn get_hashes(&self) -> &[Hash] {
        &self.hashes
    }
    pub fn clear_hashes(&mut self) {
        self.hashes.clear();
    }

    // Param is passed by value, moved
    pub fn set_hashes(&mut self, v: ::protobuf::RepeatedField<Hash>) {
        self.hashes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hashes(&mut self) -> &mut ::protobuf::RepeatedField<Hash> {
        &mut self.hashes
    }

    // Take field
    pub fn take_hashes(&mut self) -> ::protobuf::RepeatedField<Hash> {
        ::std::mem::replace(&mut self.hashes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Tool {
    fn is_initialized(&self) -> bool {
        for v in &self.hashes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._vendor = ::std::option::Option::Some(Tool_oneof__vendor::vendor(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._name = ::std::option::Option::Some(Tool_oneof__name::name(is.read_string()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._version = ::std::option::Option::Some(Tool_oneof__version::version(is.read_string()?));
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.hashes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.hashes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let ::std::option::Option::Some(ref v) = self._vendor {
            match v {
                &Tool_oneof__vendor::vendor(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._name {
            match v {
                &Tool_oneof__name::name(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._version {
            match v {
                &Tool_oneof__version::version(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.hashes {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let ::std::option::Option::Some(ref v) = self._vendor {
            match v {
                &Tool_oneof__vendor::vendor(ref v) => {
                    os.write_string(1, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._name {
            match v {
                &Tool_oneof__name::name(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._version {
            match v {
                &Tool_oneof__version::version(ref v) => {
                    os.write_string(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Tool {
        Tool::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "vendor",
                Tool::has_vendor,
                Tool::get_vendor,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "name",
                Tool::has_name,
                Tool::get_name,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "version",
                Tool::has_version,
                Tool::get_version,
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Hash>>(
                "hashes",
                |m: &Tool| { &m.hashes },
                |m: &mut Tool| { &mut m.hashes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Tool>(
                "Tool",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Tool {
        static instance: ::protobuf::rt::LazyV2<Tool> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Tool::new)
    }
}

impl ::protobuf::Clear for Tool {
    fn clear(&mut self) {
        self._vendor = ::std::option::Option::None;
        self._name = ::std::option::Option::None;
        self._version = ::std::option::Option::None;
        self.hashes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Tool {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Tool {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Property {
    // message fields
    pub name: ::std::string::String,
    // message oneof groups
    pub _value: ::std::option::Option<Property_oneof__value>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Property {
    fn default() -> &'a Property {
        <Property as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Property_oneof__value {
    value(::std::string::String),
}

impl Property {
    pub fn new() -> Property {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string value = 2;


    pub fn get_value(&self) -> &str {
        match self._value {
            ::std::option::Option::Some(Property_oneof__value::value(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_value(&mut self) {
        self._value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        match self._value {
            ::std::option::Option::Some(Property_oneof__value::value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self._value = ::std::option::Option::Some(Property_oneof__value::value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Property_oneof__value::value(_)) = self._value {
        } else {
            self._value = ::std::option::Option::Some(Property_oneof__value::value(::std::string::String::new()));
        }
        match self._value {
            ::std::option::Option::Some(Property_oneof__value::value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        if self.has_value() {
            match self._value.take() {
                ::std::option::Option::Some(Property_oneof__value::value(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for Property {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._value = ::std::option::Option::Some(Property_oneof__value::value(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let ::std::option::Option::Some(ref v) = self._value {
            match v {
                &Property_oneof__value::value(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let ::std::option::Option::Some(ref v) = self._value {
            match v {
                &Property_oneof__value::value(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Property {
        Property::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Property| { &m.name },
                |m: &mut Property| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "value",
                Property::has_value,
                Property::get_value,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Property>(
                "Property",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Property {
        static instance: ::protobuf::rt::LazyV2<Property> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Property::new)
    }
}

impl ::protobuf::Clear for Property {
    fn clear(&mut self) {
        self.name.clear();
        self._value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Property {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Property {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Composition {
    // message fields
    pub aggregate: Aggregate,
    pub assemblies: ::protobuf::RepeatedField<::std::string::String>,
    pub dependencies: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Composition {
    fn default() -> &'a Composition {
        <Composition as ::protobuf::Message>::default_instance()
    }
}

impl Composition {
    pub fn new() -> Composition {
        ::std::default::Default::default()
    }

    // .cyclonedx.v1_3.Aggregate aggregate = 1;


    pub fn get_aggregate(&self) -> Aggregate {
        self.aggregate
    }
    pub fn clear_aggregate(&mut self) {
        self.aggregate = Aggregate::AGGREGATE_NOT_SPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_aggregate(&mut self, v: Aggregate) {
        self.aggregate = v;
    }

    // repeated string assemblies = 2;


    pub fn get_assemblies(&self) -> &[::std::string::String] {
        &self.assemblies
    }
    pub fn clear_assemblies(&mut self) {
        self.assemblies.clear();
    }

    // Param is passed by value, moved
    pub fn set_assemblies(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.assemblies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_assemblies(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.assemblies
    }

    // Take field
    pub fn take_assemblies(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.assemblies, ::protobuf::RepeatedField::new())
    }

    // repeated string dependencies = 3;


    pub fn get_dependencies(&self) -> &[::std::string::String] {
        &self.dependencies
    }
    pub fn clear_dependencies(&mut self) {
        self.dependencies.clear();
    }

    // Param is passed by value, moved
    pub fn set_dependencies(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.dependencies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dependencies(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.dependencies
    }

    // Take field
    pub fn take_dependencies(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.dependencies, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Composition {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.aggregate, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.assemblies)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.dependencies)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.aggregate != Aggregate::AGGREGATE_NOT_SPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.aggregate);
        }
        for value in &self.assemblies {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.dependencies {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.aggregate != Aggregate::AGGREGATE_NOT_SPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.aggregate))?;
        }
        for v in &self.assemblies {
            os.write_string(2, &v)?;
        };
        for v in &self.dependencies {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Composition {
        Composition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Aggregate>>(
                "aggregate",
                |m: &Composition| { &m.aggregate },
                |m: &mut Composition| { &mut m.aggregate },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "assemblies",
                |m: &Composition| { &m.assemblies },
                |m: &mut Composition| { &mut m.assemblies },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dependencies",
                |m: &Composition| { &m.dependencies },
                |m: &mut Composition| { &mut m.dependencies },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Composition>(
                "Composition",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Composition {
        static instance: ::protobuf::rt::LazyV2<Composition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Composition::new)
    }
}

impl ::protobuf::Clear for Composition {
    fn clear(&mut self) {
        self.aggregate = Aggregate::AGGREGATE_NOT_SPECIFIED;
        self.assemblies.clear();
        self.dependencies.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Composition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Composition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct EvidenceCopyright {
    // message fields
    pub text: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EvidenceCopyright {
    fn default() -> &'a EvidenceCopyright {
        <EvidenceCopyright as ::protobuf::Message>::default_instance()
    }
}

impl EvidenceCopyright {
    pub fn new() -> EvidenceCopyright {
        ::std::default::Default::default()
    }

    // string text = 1;


    pub fn get_text(&self) -> &str {
        &self.text
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        &mut self.text
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.text, ::std::string::String::new())
    }
}

impl ::protobuf::Message for EvidenceCopyright {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.text);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.text.is_empty() {
            os.write_string(1, &self.text)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EvidenceCopyright {
        EvidenceCopyright::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "text",
                |m: &EvidenceCopyright| { &m.text },
                |m: &mut EvidenceCopyright| { &mut m.text },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EvidenceCopyright>(
                "EvidenceCopyright",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EvidenceCopyright {
        static instance: ::protobuf::rt::LazyV2<EvidenceCopyright> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EvidenceCopyright::new)
    }
}

impl ::protobuf::Clear for EvidenceCopyright {
    fn clear(&mut self) {
        self.text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EvidenceCopyright {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EvidenceCopyright {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Evidence {
    // message fields
    pub licenses: ::protobuf::RepeatedField<LicenseChoice>,
    pub copyright: ::protobuf::RepeatedField<EvidenceCopyright>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Evidence {
    fn default() -> &'a Evidence {
        <Evidence as ::protobuf::Message>::default_instance()
    }
}

impl Evidence {
    pub fn new() -> Evidence {
        ::std::default::Default::default()
    }

    // repeated .cyclonedx.v1_3.LicenseChoice licenses = 1;


    pub fn get_licenses(&self) -> &[LicenseChoice] {
        &self.licenses
    }
    pub fn clear_licenses(&mut self) {
        self.licenses.clear();
    }

    // Param is passed by value, moved
    pub fn set_licenses(&mut self, v: ::protobuf::RepeatedField<LicenseChoice>) {
        self.licenses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_licenses(&mut self) -> &mut ::protobuf::RepeatedField<LicenseChoice> {
        &mut self.licenses
    }

    // Take field
    pub fn take_licenses(&mut self) -> ::protobuf::RepeatedField<LicenseChoice> {
        ::std::mem::replace(&mut self.licenses, ::protobuf::RepeatedField::new())
    }

    // repeated .cyclonedx.v1_3.EvidenceCopyright copyright = 2;


    pub fn get_copyright(&self) -> &[EvidenceCopyright] {
        &self.copyright
    }
    pub fn clear_copyright(&mut self) {
        self.copyright.clear();
    }

    // Param is passed by value, moved
    pub fn set_copyright(&mut self, v: ::protobuf::RepeatedField<EvidenceCopyright>) {
        self.copyright = v;
    }

    // Mutable pointer to the field.
    pub fn mut_copyright(&mut self) -> &mut ::protobuf::RepeatedField<EvidenceCopyright> {
        &mut self.copyright
    }

    // Take field
    pub fn take_copyright(&mut self) -> ::protobuf::RepeatedField<EvidenceCopyright> {
        ::std::mem::replace(&mut self.copyright, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Evidence {
    fn is_initialized(&self) -> bool {
        for v in &self.licenses {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.copyright {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.licenses)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.copyright)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.licenses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.copyright {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.licenses {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.copyright {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Evidence {
        Evidence::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LicenseChoice>>(
                "licenses",
                |m: &Evidence| { &m.licenses },
                |m: &mut Evidence| { &mut m.licenses },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EvidenceCopyright>>(
                "copyright",
                |m: &Evidence| { &m.copyright },
                |m: &mut Evidence| { &mut m.copyright },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Evidence>(
                "Evidence",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Evidence {
        static instance: ::protobuf::rt::LazyV2<Evidence> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Evidence::new)
    }
}

impl ::protobuf::Clear for Evidence {
    fn clear(&mut self) {
        self.licenses.clear();
        self.copyright.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Evidence {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Evidence {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Classification {
    CLASSIFICATION_NULL = 0,
    CLASSIFICATION_APPLICATION = 1,
    CLASSIFICATION_FRAMEWORK = 2,
    CLASSIFICATION_LIBRARY = 3,
    CLASSIFICATION_OPERATING_SYSTEM = 4,
    CLASSIFICATION_DEVICE = 5,
    CLASSIFICATION_FILE = 6,
    CLASSIFICATION_CONTAINER = 7,
    CLASSIFICATION_FIRMWARE = 8,
}

impl ::protobuf::ProtobufEnum for Classification {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Classification> {
        match value {
            0 => ::std::option::Option::Some(Classification::CLASSIFICATION_NULL),
            1 => ::std::option::Option::Some(Classification::CLASSIFICATION_APPLICATION),
            2 => ::std::option::Option::Some(Classification::CLASSIFICATION_FRAMEWORK),
            3 => ::std::option::Option::Some(Classification::CLASSIFICATION_LIBRARY),
            4 => ::std::option::Option::Some(Classification::CLASSIFICATION_OPERATING_SYSTEM),
            5 => ::std::option::Option::Some(Classification::CLASSIFICATION_DEVICE),
            6 => ::std::option::Option::Some(Classification::CLASSIFICATION_FILE),
            7 => ::std::option::Option::Some(Classification::CLASSIFICATION_CONTAINER),
            8 => ::std::option::Option::Some(Classification::CLASSIFICATION_FIRMWARE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Classification] = &[
            Classification::CLASSIFICATION_NULL,
            Classification::CLASSIFICATION_APPLICATION,
            Classification::CLASSIFICATION_FRAMEWORK,
            Classification::CLASSIFICATION_LIBRARY,
            Classification::CLASSIFICATION_OPERATING_SYSTEM,
            Classification::CLASSIFICATION_DEVICE,
            Classification::CLASSIFICATION_FILE,
            Classification::CLASSIFICATION_CONTAINER,
            Classification::CLASSIFICATION_FIRMWARE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Classification>("Classification", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Classification {
}

impl ::std::default::Default for Classification {
    fn default() -> Self {
        Classification::CLASSIFICATION_NULL
    }
}

impl ::protobuf::reflect::ProtobufValue for Classification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum DataFlow {
    DATA_FLOW_NULL = 0,
    DATA_FLOW_INBOUND = 1,
    DATA_FLOW_OUTBOUND = 2,
    DATA_FLOW_BI_DIRECTIONAL = 3,
    DATA_FLOW_UNKNOWN = 4,
}

impl ::protobuf::ProtobufEnum for DataFlow {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DataFlow> {
        match value {
            0 => ::std::option::Option::Some(DataFlow::DATA_FLOW_NULL),
            1 => ::std::option::Option::Some(DataFlow::DATA_FLOW_INBOUND),
            2 => ::std::option::Option::Some(DataFlow::DATA_FLOW_OUTBOUND),
            3 => ::std::option::Option::Some(DataFlow::DATA_FLOW_BI_DIRECTIONAL),
            4 => ::std::option::Option::Some(DataFlow::DATA_FLOW_UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DataFlow] = &[
            DataFlow::DATA_FLOW_NULL,
            DataFlow::DATA_FLOW_INBOUND,
            DataFlow::DATA_FLOW_OUTBOUND,
            DataFlow::DATA_FLOW_BI_DIRECTIONAL,
            DataFlow::DATA_FLOW_UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DataFlow>("DataFlow", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DataFlow {
}

impl ::std::default::Default for DataFlow {
    fn default() -> Self {
        DataFlow::DATA_FLOW_NULL
    }
}

impl ::protobuf::reflect::ProtobufValue for DataFlow {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum ExternalReferenceType {
    EXTERNAL_REFERENCE_TYPE_OTHER = 0,
    EXTERNAL_REFERENCE_TYPE_VCS = 1,
    EXTERNAL_REFERENCE_TYPE_ISSUE_TRACKER = 2,
    EXTERNAL_REFERENCE_TYPE_WEBSITE = 3,
    EXTERNAL_REFERENCE_TYPE_ADVISORIES = 4,
    EXTERNAL_REFERENCE_TYPE_BOM = 5,
    EXTERNAL_REFERENCE_TYPE_MAILING_LIST = 6,
    EXTERNAL_REFERENCE_TYPE_SOCIAL = 7,
    EXTERNAL_REFERENCE_TYPE_CHAT = 8,
    EXTERNAL_REFERENCE_TYPE_DOCUMENTATION = 9,
    EXTERNAL_REFERENCE_TYPE_SUPPORT = 10,
    EXTERNAL_REFERENCE_TYPE_DISTRIBUTION = 11,
    EXTERNAL_REFERENCE_TYPE_LICENSE = 12,
    EXTERNAL_REFERENCE_TYPE_BUILD_META = 13,
    EXTERNAL_REFERENCE_TYPE_BUILD_SYSTEM = 14,
}

impl ::protobuf::ProtobufEnum for ExternalReferenceType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ExternalReferenceType> {
        match value {
            0 => ::std::option::Option::Some(ExternalReferenceType::EXTERNAL_REFERENCE_TYPE_OTHER),
            1 => ::std::option::Option::Some(ExternalReferenceType::EXTERNAL_REFERENCE_TYPE_VCS),
            2 => ::std::option::Option::Some(ExternalReferenceType::EXTERNAL_REFERENCE_TYPE_ISSUE_TRACKER),
            3 => ::std::option::Option::Some(ExternalReferenceType::EXTERNAL_REFERENCE_TYPE_WEBSITE),
            4 => ::std::option::Option::Some(ExternalReferenceType::EXTERNAL_REFERENCE_TYPE_ADVISORIES),
            5 => ::std::option::Option::Some(ExternalReferenceType::EXTERNAL_REFERENCE_TYPE_BOM),
            6 => ::std::option::Option::Some(ExternalReferenceType::EXTERNAL_REFERENCE_TYPE_MAILING_LIST),
            7 => ::std::option::Option::Some(ExternalReferenceType::EXTERNAL_REFERENCE_TYPE_SOCIAL),
            8 => ::std::option::Option::Some(ExternalReferenceType::EXTERNAL_REFERENCE_TYPE_CHAT),
            9 => ::std::option::Option::Some(ExternalReferenceType::EXTERNAL_REFERENCE_TYPE_DOCUMENTATION),
            10 => ::std::option::Option::Some(ExternalReferenceType::EXTERNAL_REFERENCE_TYPE_SUPPORT),
            11 => ::std::option::Option::Some(ExternalReferenceType::EXTERNAL_REFERENCE_TYPE_DISTRIBUTION),
            12 => ::std::option::Option::Some(ExternalReferenceType::EXTERNAL_REFERENCE_TYPE_LICENSE),
            13 => ::std::option::Option::Some(ExternalReferenceType::EXTERNAL_REFERENCE_TYPE_BUILD_META),
            14 => ::std::option::Option::Some(ExternalReferenceType::EXTERNAL_REFERENCE_TYPE_BUILD_SYSTEM),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ExternalReferenceType] = &[
            ExternalReferenceType::EXTERNAL_REFERENCE_TYPE_OTHER,
            ExternalReferenceType::EXTERNAL_REFERENCE_TYPE_VCS,
            ExternalReferenceType::EXTERNAL_REFERENCE_TYPE_ISSUE_TRACKER,
            ExternalReferenceType::EXTERNAL_REFERENCE_TYPE_WEBSITE,
            ExternalReferenceType::EXTERNAL_REFERENCE_TYPE_ADVISORIES,
            ExternalReferenceType::EXTERNAL_REFERENCE_TYPE_BOM,
            ExternalReferenceType::EXTERNAL_REFERENCE_TYPE_MAILING_LIST,
            ExternalReferenceType::EXTERNAL_REFERENCE_TYPE_SOCIAL,
            ExternalReferenceType::EXTERNAL_REFERENCE_TYPE_CHAT,
            ExternalReferenceType::EXTERNAL_REFERENCE_TYPE_DOCUMENTATION,
            ExternalReferenceType::EXTERNAL_REFERENCE_TYPE_SUPPORT,
            ExternalReferenceType::EXTERNAL_REFERENCE_TYPE_DISTRIBUTION,
            ExternalReferenceType::EXTERNAL_REFERENCE_TYPE_LICENSE,
            ExternalReferenceType::EXTERNAL_REFERENCE_TYPE_BUILD_META,
            ExternalReferenceType::EXTERNAL_REFERENCE_TYPE_BUILD_SYSTEM,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ExternalReferenceType>("ExternalReferenceType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ExternalReferenceType {
}

impl ::std::default::Default for ExternalReferenceType {
    fn default() -> Self {
        ExternalReferenceType::EXTERNAL_REFERENCE_TYPE_OTHER
    }
}

impl ::protobuf::reflect::ProtobufValue for ExternalReferenceType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum HashAlg {
    HASH_ALG_NULL = 0,
    HASH_ALG_MD_5 = 1,
    HASH_ALG_SHA_1 = 2,
    HASH_ALG_SHA_256 = 3,
    HASH_ALG_SHA_384 = 4,
    HASH_ALG_SHA_512 = 5,
    HASH_ALG_SHA_3_256 = 6,
    HASH_ALG_SHA_3_384 = 7,
    HASH_ALG_SHA_3_512 = 8,
    HASH_ALG_BLAKE_2_B_256 = 9,
    HASH_ALG_BLAKE_2_B_384 = 10,
    HASH_ALG_BLAKE_2_B_512 = 11,
    HASH_ALG_BLAKE_3 = 12,
}

impl ::protobuf::ProtobufEnum for HashAlg {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<HashAlg> {
        match value {
            0 => ::std::option::Option::Some(HashAlg::HASH_ALG_NULL),
            1 => ::std::option::Option::Some(HashAlg::HASH_ALG_MD_5),
            2 => ::std::option::Option::Some(HashAlg::HASH_ALG_SHA_1),
            3 => ::std::option::Option::Some(HashAlg::HASH_ALG_SHA_256),
            4 => ::std::option::Option::Some(HashAlg::HASH_ALG_SHA_384),
            5 => ::std::option::Option::Some(HashAlg::HASH_ALG_SHA_512),
            6 => ::std::option::Option::Some(HashAlg::HASH_ALG_SHA_3_256),
            7 => ::std::option::Option::Some(HashAlg::HASH_ALG_SHA_3_384),
            8 => ::std::option::Option::Some(HashAlg::HASH_ALG_SHA_3_512),
            9 => ::std::option::Option::Some(HashAlg::HASH_ALG_BLAKE_2_B_256),
            10 => ::std::option::Option::Some(HashAlg::HASH_ALG_BLAKE_2_B_384),
            11 => ::std::option::Option::Some(HashAlg::HASH_ALG_BLAKE_2_B_512),
            12 => ::std::option::Option::Some(HashAlg::HASH_ALG_BLAKE_3),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [HashAlg] = &[
            HashAlg::HASH_ALG_NULL,
            HashAlg::HASH_ALG_MD_5,
            HashAlg::HASH_ALG_SHA_1,
            HashAlg::HASH_ALG_SHA_256,
            HashAlg::HASH_ALG_SHA_384,
            HashAlg::HASH_ALG_SHA_512,
            HashAlg::HASH_ALG_SHA_3_256,
            HashAlg::HASH_ALG_SHA_3_384,
            HashAlg::HASH_ALG_SHA_3_512,
            HashAlg::HASH_ALG_BLAKE_2_B_256,
            HashAlg::HASH_ALG_BLAKE_2_B_384,
            HashAlg::HASH_ALG_BLAKE_2_B_512,
            HashAlg::HASH_ALG_BLAKE_3,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<HashAlg>("HashAlg", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for HashAlg {
}

impl ::std::default::Default for HashAlg {
    fn default() -> Self {
        HashAlg::HASH_ALG_NULL
    }
}

impl ::protobuf::reflect::ProtobufValue for HashAlg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum IssueClassification {
    ISSUE_CLASSIFICATION_NULL = 0,
    ISSUE_CLASSIFICATION_DEFECT = 1,
    ISSUE_CLASSIFICATION_ENHANCEMENT = 2,
    ISSUE_CLASSIFICATION_SECURITY = 3,
}

impl ::protobuf::ProtobufEnum for IssueClassification {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<IssueClassification> {
        match value {
            0 => ::std::option::Option::Some(IssueClassification::ISSUE_CLASSIFICATION_NULL),
            1 => ::std::option::Option::Some(IssueClassification::ISSUE_CLASSIFICATION_DEFECT),
            2 => ::std::option::Option::Some(IssueClassification::ISSUE_CLASSIFICATION_ENHANCEMENT),
            3 => ::std::option::Option::Some(IssueClassification::ISSUE_CLASSIFICATION_SECURITY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [IssueClassification] = &[
            IssueClassification::ISSUE_CLASSIFICATION_NULL,
            IssueClassification::ISSUE_CLASSIFICATION_DEFECT,
            IssueClassification::ISSUE_CLASSIFICATION_ENHANCEMENT,
            IssueClassification::ISSUE_CLASSIFICATION_SECURITY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<IssueClassification>("IssueClassification", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for IssueClassification {
}

impl ::std::default::Default for IssueClassification {
    fn default() -> Self {
        IssueClassification::ISSUE_CLASSIFICATION_NULL
    }
}

impl ::protobuf::reflect::ProtobufValue for IssueClassification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum PatchClassification {
    PATCH_CLASSIFICATION_NULL = 0,
    PATCH_CLASSIFICATION_UNOFFICIAL = 1,
    PATCH_CLASSIFICATION_MONKEY = 2,
    PATCH_CLASSIFICATION_BACKPORT = 3,
    PATCH_CLASSIFICATION_CHERRY_PICK = 4,
}

impl ::protobuf::ProtobufEnum for PatchClassification {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PatchClassification> {
        match value {
            0 => ::std::option::Option::Some(PatchClassification::PATCH_CLASSIFICATION_NULL),
            1 => ::std::option::Option::Some(PatchClassification::PATCH_CLASSIFICATION_UNOFFICIAL),
            2 => ::std::option::Option::Some(PatchClassification::PATCH_CLASSIFICATION_MONKEY),
            3 => ::std::option::Option::Some(PatchClassification::PATCH_CLASSIFICATION_BACKPORT),
            4 => ::std::option::Option::Some(PatchClassification::PATCH_CLASSIFICATION_CHERRY_PICK),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PatchClassification] = &[
            PatchClassification::PATCH_CLASSIFICATION_NULL,
            PatchClassification::PATCH_CLASSIFICATION_UNOFFICIAL,
            PatchClassification::PATCH_CLASSIFICATION_MONKEY,
            PatchClassification::PATCH_CLASSIFICATION_BACKPORT,
            PatchClassification::PATCH_CLASSIFICATION_CHERRY_PICK,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PatchClassification>("PatchClassification", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PatchClassification {
}

impl ::std::default::Default for PatchClassification {
    fn default() -> Self {
        PatchClassification::PATCH_CLASSIFICATION_NULL
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchClassification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Scope {
    SCOPE_UNSPECIFIED = 0,
    SCOPE_REQUIRED = 1,
    SCOPE_OPTIONAL = 2,
    SCOPE_EXCLUDED = 3,
}

impl ::protobuf::ProtobufEnum for Scope {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Scope> {
        match value {
            0 => ::std::option::Option::Some(Scope::SCOPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(Scope::SCOPE_REQUIRED),
            2 => ::std::option::Option::Some(Scope::SCOPE_OPTIONAL),
            3 => ::std::option::Option::Some(Scope::SCOPE_EXCLUDED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Scope] = &[
            Scope::SCOPE_UNSPECIFIED,
            Scope::SCOPE_REQUIRED,
            Scope::SCOPE_OPTIONAL,
            Scope::SCOPE_EXCLUDED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Scope>("Scope", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Scope {
}

impl ::std::default::Default for Scope {
    fn default() -> Self {
        Scope::SCOPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for Scope {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Aggregate {
    AGGREGATE_NOT_SPECIFIED = 0,
    AGGREGATE_COMPLETE = 1,
    AGGREGATE_INCOMPLETE = 2,
    AGGREGATE_INCOMPLETE_FIRST_PARTY_ONLY = 3,
    AGGREGATE_INCOMPLETE_THIRD_PARTY_ONLY = 4,
    AGGREGATE_UNKNOWN = 5,
}

impl ::protobuf::ProtobufEnum for Aggregate {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Aggregate> {
        match value {
            0 => ::std::option::Option::Some(Aggregate::AGGREGATE_NOT_SPECIFIED),
            1 => ::std::option::Option::Some(Aggregate::AGGREGATE_COMPLETE),
            2 => ::std::option::Option::Some(Aggregate::AGGREGATE_INCOMPLETE),
            3 => ::std::option::Option::Some(Aggregate::AGGREGATE_INCOMPLETE_FIRST_PARTY_ONLY),
            4 => ::std::option::Option::Some(Aggregate::AGGREGATE_INCOMPLETE_THIRD_PARTY_ONLY),
            5 => ::std::option::Option::Some(Aggregate::AGGREGATE_UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Aggregate] = &[
            Aggregate::AGGREGATE_NOT_SPECIFIED,
            Aggregate::AGGREGATE_COMPLETE,
            Aggregate::AGGREGATE_INCOMPLETE,
            Aggregate::AGGREGATE_INCOMPLETE_FIRST_PARTY_ONLY,
            Aggregate::AGGREGATE_INCOMPLETE_THIRD_PARTY_ONLY,
            Aggregate::AGGREGATE_UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Aggregate>("Aggregate", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Aggregate {
}

impl ::std::default::Default for Aggregate {
    fn default() -> Self {
        Aggregate::AGGREGATE_NOT_SPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for Aggregate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rbom-1.3.proto\x12\x0ecyclonedx.v1_3\x1a\x1fgoogle/protobuf/timestamp\
    .proto\"\x8b\x01\n\x0cAttachedText\x12&\n\x0ccontent_type\x18\x01\x20\
    \x01(\tH\0R\x0bcontentType\x88\x01\x01\x12\x1f\n\x08encoding\x18\x02\x20\
    \x01(\tH\x01R\x08encoding\x88\x01\x01\x12\x14\n\x05value\x18\x03\x20\x01\
    (\tR\x05valueB\x0f\n\r_content_typeB\x0b\n\t_encoding\"\x9c\x04\n\x03Bom\
    \x12!\n\x0cspec_version\x18\x01\x20\x01(\tR\x0bspecVersion\x12\x1d\n\x07\
    version\x18\x02\x20\x01(\x05H\0R\x07version\x88\x01\x01\x12(\n\rserial_n\
    umber\x18\x03\x20\x01(\tH\x01R\x0cserialNumber\x88\x01\x01\x129\n\x08met\
    adata\x18\x04\x20\x01(\x0b2\x18.cyclonedx.v1_3.MetadataH\x02R\x08metadat\
    a\x88\x01\x01\x129\n\ncomponents\x18\x05\x20\x03(\x0b2\x19.cyclonedx.v1_\
    3.ComponentR\ncomponents\x123\n\x08services\x18\x06\x20\x03(\x0b2\x17.cy\
    clonedx.v1_3.ServiceR\x08services\x12R\n\x13external_references\x18\x07\
    \x20\x03(\x0b2!.cyclonedx.v1_3.ExternalReferenceR\x12externalReferences\
    \x12>\n\x0cdependencies\x18\x08\x20\x03(\x0b2\x1a.cyclonedx.v1_3.Depende\
    ncyR\x0cdependencies\x12?\n\x0ccompositions\x18\t\x20\x03(\x0b2\x1b.cycl\
    onedx.v1_3.CompositionR\x0ccompositionsB\n\n\x08_versionB\x10\n\x0e_seri\
    al_numberB\x0b\n\t_metadata\"\x92\x02\n\x06Commit\x12\x15\n\x03uid\x18\
    \x01\x20\x01(\tH\0R\x03uid\x88\x01\x01\x12\x15\n\x03url\x18\x02\x20\x01(\
    \tH\x01R\x03url\x88\x01\x01\x12?\n\x06author\x18\x03\x20\x01(\x0b2\".cyc\
    lonedx.v1_3.IdentifiableActionH\x02R\x06author\x88\x01\x01\x12E\n\tcommi\
    tter\x18\x04\x20\x01(\x0b2\".cyclonedx.v1_3.IdentifiableActionH\x03R\tco\
    mmitter\x88\x01\x01\x12\x1d\n\x07message\x18\x05\x20\x01(\tH\x04R\x07mes\
    sage\x88\x01\x01B\x06\n\x04_uidB\x06\n\x04_urlB\t\n\x07_authorB\x0c\n\n_\
    committerB\n\n\x08_message\"\x94\t\n\tComponent\x122\n\x04type\x18\x01\
    \x20\x01(\x0e2\x1e.cyclonedx.v1_3.ClassificationR\x04type\x12\x20\n\tmim\
    e_type\x18\x02\x20\x01(\tH\0R\x08mimeType\x88\x01\x01\x12\x1c\n\x07bom_r\
    ef\x18\x03\x20\x01(\tH\x01R\x06bomRef\x88\x01\x01\x12E\n\x08supplier\x18\
    \x04\x20\x01(\x0b2$.cyclonedx.v1_3.OrganizationalEntityH\x02R\x08supplie\
    r\x88\x01\x01\x12\x1b\n\x06author\x18\x05\x20\x01(\tH\x03R\x06author\x88\
    \x01\x01\x12!\n\tpublisher\x18\x06\x20\x01(\tH\x04R\tpublisher\x88\x01\
    \x01\x12\x19\n\x05group\x18\x07\x20\x01(\tH\x05R\x05group\x88\x01\x01\
    \x12\x12\n\x04name\x18\x08\x20\x01(\tR\x04name\x12\x18\n\x07version\x18\
    \t\x20\x01(\tR\x07version\x12%\n\x0bdescription\x18\n\x20\x01(\tH\x06R\
    \x0bdescription\x88\x01\x01\x120\n\x05scope\x18\x0b\x20\x01(\x0e2\x15.cy\
    clonedx.v1_3.ScopeH\x07R\x05scope\x88\x01\x01\x12,\n\x06hashes\x18\x0c\
    \x20\x03(\x0b2\x14.cyclonedx.v1_3.HashR\x06hashes\x129\n\x08licenses\x18\
    \r\x20\x03(\x0b2\x1d.cyclonedx.v1_3.LicenseChoiceR\x08licenses\x12!\n\tc\
    opyright\x18\x0e\x20\x01(\tH\x08R\tcopyright\x88\x01\x01\x12\x15\n\x03cp\
    e\x18\x0f\x20\x01(\tH\tR\x03cpe\x88\x01\x01\x12\x17\n\x04purl\x18\x10\
    \x20\x01(\tH\nR\x04purl\x88\x01\x01\x12-\n\x04swid\x18\x11\x20\x01(\x0b2\
    \x14.cyclonedx.v1_3.SwidH\x0bR\x04swid\x88\x01\x01\x12\x1f\n\x08modified\
    \x18\x12\x20\x01(\x08H\x0cR\x08modified\x88\x01\x01\x129\n\x08pedigree\
    \x18\x13\x20\x01(\x0b2\x18.cyclonedx.v1_3.PedigreeH\rR\x08pedigree\x88\
    \x01\x01\x12R\n\x13external_references\x18\x14\x20\x03(\x0b2!.cyclonedx.\
    v1_3.ExternalReferenceR\x12externalReferences\x129\n\ncomponents\x18\x15\
    \x20\x03(\x0b2\x19.cyclonedx.v1_3.ComponentR\ncomponents\x128\n\npropert\
    ies\x18\x16\x20\x03(\x0b2\x18.cyclonedx.v1_3.PropertyR\nproperties\x124\
    \n\x08evidence\x18\x17\x20\x03(\x0b2\x18.cyclonedx.v1_3.EvidenceR\x08evi\
    denceB\x0c\n\n_mime_typeB\n\n\x08_bom_refB\x0b\n\t_supplierB\t\n\x07_aut\
    horB\x0c\n\n_publisherB\x08\n\x06_groupB\x0e\n\x0c_descriptionB\x08\n\
    \x06_scopeB\x0c\n\n_copyrightB\x06\n\x04_cpeB\x07\n\x05_purlB\x07\n\x05_\
    swidB\x0b\n\t_modifiedB\x0b\n\t_pedigree\"X\n\x12DataClassification\x12,\
    \n\x04flow\x18\x01\x20\x01(\x0e2\x18.cyclonedx.v1_3.DataFlowR\x04flow\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\"^\n\nDependency\x12\
    \x10\n\x03ref\x18\x01\x20\x01(\tR\x03ref\x12>\n\x0cdependencies\x18\x02\
    \x20\x03(\x0b2\x1a.cyclonedx.v1_3.DependencyR\x0cdependencies\"e\n\x04Di\
    ff\x125\n\x04text\x18\x01\x20\x01(\x0b2\x1c.cyclonedx.v1_3.AttachedTextH\
    \0R\x04text\x88\x01\x01\x12\x15\n\x03url\x18\x02\x20\x01(\tH\x01R\x03url\
    \x88\x01\x01B\x07\n\x05_textB\x06\n\x04_url\"\xb9\x01\n\x11ExternalRefer\
    ence\x129\n\x04type\x18\x01\x20\x01(\x0e2%.cyclonedx.v1_3.ExternalRefere\
    nceTypeR\x04type\x12\x10\n\x03url\x18\x02\x20\x01(\tR\x03url\x12\x1d\n\
    \x07comment\x18\x03\x20\x01(\tH\0R\x07comment\x88\x01\x01\x12,\n\x06hash\
    es\x18\x04\x20\x03(\x0b2\x14.cyclonedx.v1_3.HashR\x06hashesB\n\n\x08_com\
    ment\"G\n\x04Hash\x12)\n\x03alg\x18\x01\x20\x01(\x0e2\x17.cyclonedx.v1_3\
    .HashAlgR\x03alg\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\"\xa8\
    \x01\n\x12IdentifiableAction\x12=\n\ttimestamp\x18\x01\x20\x01(\x0b2\x1a\
    .google.protobuf.TimestampH\0R\ttimestamp\x88\x01\x01\x12\x17\n\x04name\
    \x18\x02\x20\x01(\tH\x01R\x04name\x88\x01\x01\x12\x19\n\x05email\x18\x03\
    \x20\x01(\tH\x02R\x05email\x88\x01\x01B\x0c\n\n_timestampB\x07\n\x05_nam\
    eB\x08\n\x06_email\"\x95\x02\n\x05Issue\x127\n\x04type\x18\x01\x20\x01(\
    \x0e2#.cyclonedx.v1_3.IssueClassificationR\x04type\x12\x13\n\x02id\x18\
    \x02\x20\x01(\tH\0R\x02id\x88\x01\x01\x12\x17\n\x04name\x18\x03\x20\x01(\
    \tH\x01R\x04name\x88\x01\x01\x12%\n\x0bdescription\x18\x04\x20\x01(\tH\
    \x02R\x0bdescription\x88\x01\x01\x123\n\x06source\x18\x05\x20\x01(\x0b2\
    \x16.cyclonedx.v1_3.SourceH\x03R\x06source\x88\x01\x01\x12\x1e\n\nrefere\
    nces\x18\x06\x20\x03(\tR\nreferencesB\x05\n\x03_idB\x07\n\x05_nameB\x0e\
    \n\x0c_descriptionB\t\n\x07_source\"I\n\x06Source\x12\x17\n\x04name\x18\
    \x01\x20\x01(\tH\0R\x04name\x88\x01\x01\x12\x15\n\x03url\x18\x02\x20\x01\
    (\tH\x01R\x03url\x88\x01\x01B\x07\n\x05_nameB\x06\n\x04_url\"p\n\rLicens\
    eChoice\x123\n\x07license\x18\x01\x20\x01(\x0b2\x17.cyclonedx.v1_3.Licen\
    seH\0R\x07license\x12\x20\n\nexpression\x18\x02\x20\x01(\tH\0R\nexpressi\
    onB\x08\n\x06choice\"\x9b\x01\n\x07License\x12\x10\n\x02id\x18\x01\x20\
    \x01(\tH\0R\x02id\x12\x14\n\x04name\x18\x02\x20\x01(\tH\0R\x04name\x125\
    \n\x04text\x18\x03\x20\x01(\x0b2\x1c.cyclonedx.v1_3.AttachedTextH\x01R\
    \x04text\x88\x01\x01\x12\x15\n\x03url\x18\x04\x20\x01(\tH\x02R\x03url\
    \x88\x01\x01B\t\n\x07licenseB\x07\n\x05_textB\x06\n\x04_url\"\xc8\x04\n\
    \x08Metadata\x12=\n\ttimestamp\x18\x01\x20\x01(\x0b2\x1a.google.protobuf\
    .TimestampH\0R\ttimestamp\x88\x01\x01\x12*\n\x05tools\x18\x02\x20\x03(\
    \x0b2\x14.cyclonedx.v1_3.ToolR\x05tools\x12?\n\x07authors\x18\x03\x20\
    \x03(\x0b2%.cyclonedx.v1_3.OrganizationalContactR\x07authors\x12<\n\tcom\
    ponent\x18\x04\x20\x01(\x0b2\x19.cyclonedx.v1_3.ComponentH\x01R\tcompone\
    nt\x88\x01\x01\x12K\n\x0bmanufacture\x18\x05\x20\x01(\x0b2$.cyclonedx.v1\
    _3.OrganizationalEntityH\x02R\x0bmanufacture\x88\x01\x01\x12E\n\x08suppl\
    ier\x18\x06\x20\x01(\x0b2$.cyclonedx.v1_3.OrganizationalEntityH\x03R\x08\
    supplier\x88\x01\x01\x12>\n\x08licenses\x18\x07\x20\x01(\x0b2\x1d.cyclon\
    edx.v1_3.LicenseChoiceH\x04R\x08licenses\x88\x01\x01\x128\n\nproperties\
    \x18\x08\x20\x03(\x0b2\x18.cyclonedx.v1_3.PropertyR\npropertiesB\x0c\n\n\
    _timestampB\x0c\n\n_componentB\x0e\n\x0c_manufactureB\x0b\n\t_supplierB\
    \x0b\n\t_licenses\"\x83\x01\n\x15OrganizationalContact\x12\x17\n\x04name\
    \x18\x01\x20\x01(\tH\0R\x04name\x88\x01\x01\x12\x19\n\x05email\x18\x02\
    \x20\x01(\tH\x01R\x05email\x88\x01\x01\x12\x19\n\x05phone\x18\x03\x20\
    \x01(\tH\x02R\x05phone\x88\x01\x01B\x07\n\x05_nameB\x08\n\x06_emailB\x08\
    \n\x06_phone\"\x8b\x01\n\x14OrganizationalEntity\x12\x17\n\x04name\x18\
    \x01\x20\x01(\tH\0R\x04name\x88\x01\x01\x12\x10\n\x03url\x18\x02\x20\x03\
    (\tR\x03url\x12?\n\x07contact\x18\x03\x20\x03(\x0b2%.cyclonedx.v1_3.Orga\
    nizationalContactR\x07contactB\x07\n\x05_name\"\xab\x01\n\x05Patch\x127\
    \n\x04type\x18\x01\x20\x01(\x0e2#.cyclonedx.v1_3.PatchClassificationR\
    \x04type\x12-\n\x04diff\x18\x02\x20\x01(\x0b2\x14.cyclonedx.v1_3.DiffH\0\
    R\x04diff\x88\x01\x01\x121\n\x08resolves\x18\x03\x20\x03(\x0b2\x15.cyclo\
    nedx.v1_3.IssueR\x08resolvesB\x07\n\x05_diff\"\xbf\x02\n\x08Pedigree\x12\
    7\n\tancestors\x18\x01\x20\x03(\x0b2\x19.cyclonedx.v1_3.ComponentR\tance\
    stors\x12;\n\x0bdescendants\x18\x02\x20\x03(\x0b2\x19.cyclonedx.v1_3.Com\
    ponentR\x0bdescendants\x125\n\x08variants\x18\x03\x20\x03(\x0b2\x19.cycl\
    onedx.v1_3.ComponentR\x08variants\x120\n\x07commits\x18\x04\x20\x03(\x0b\
    2\x16.cyclonedx.v1_3.CommitR\x07commits\x12/\n\x07patches\x18\x05\x20\
    \x03(\x0b2\x15.cyclonedx.v1_3.PatchR\x07patches\x12\x19\n\x05notes\x18\
    \x06\x20\x01(\tH\0R\x05notes\x88\x01\x01B\x08\n\x06_notes\"\xf7\x05\n\
    \x07Service\x12\x1c\n\x07bom_ref\x18\x01\x20\x01(\tH\0R\x06bomRef\x88\
    \x01\x01\x12E\n\x08provider\x18\x02\x20\x01(\x0b2$.cyclonedx.v1_3.Organi\
    zationalEntityH\x01R\x08provider\x88\x01\x01\x12\x19\n\x05group\x18\x03\
    \x20\x01(\tH\x02R\x05group\x88\x01\x01\x12\x12\n\x04name\x18\x04\x20\x01\
    (\tR\x04name\x12\x1d\n\x07version\x18\x05\x20\x01(\tH\x03R\x07version\
    \x88\x01\x01\x12%\n\x0bdescription\x18\x06\x20\x01(\tH\x04R\x0bdescripti\
    on\x88\x01\x01\x12\x1c\n\tendpoints\x18\x07\x20\x03(\tR\tendpoints\x12)\
    \n\rauthenticated\x18\x08\x20\x01(\x08H\x05R\rauthenticated\x88\x01\x01\
    \x12-\n\x10x_trust_boundary\x18\t\x20\x01(\x08H\x06R\x0exTrustBoundary\
    \x88\x01\x01\x126\n\x04data\x18\n\x20\x03(\x0b2\".cyclonedx.v1_3.DataCla\
    ssificationR\x04data\x129\n\x08licenses\x18\x0b\x20\x03(\x0b2\x1d.cyclon\
    edx.v1_3.LicenseChoiceR\x08licenses\x12R\n\x13external_references\x18\
    \x0c\x20\x03(\x0b2!.cyclonedx.v1_3.ExternalReferenceR\x12externalReferen\
    ces\x123\n\x08services\x18\r\x20\x03(\x0b2\x17.cyclonedx.v1_3.ServiceR\
    \x08services\x128\n\nproperties\x18\x0e\x20\x03(\x0b2\x18.cyclonedx.v1_3\
    .PropertyR\npropertiesB\n\n\x08_bom_refB\x0b\n\t_providerB\x08\n\x06_gro\
    upB\n\n\x08_versionB\x0e\n\x0c_descriptionB\x10\n\x0e_authenticatedB\x13\
    \n\x11_x_trust_boundary\"\x96\x02\n\x04Swid\x12\x15\n\x06tag_id\x18\x01\
    \x20\x01(\tR\x05tagId\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\
    \x1d\n\x07version\x18\x03\x20\x01(\tH\0R\x07version\x88\x01\x01\x12$\n\
    \x0btag_version\x18\x04\x20\x01(\x05H\x01R\ntagVersion\x88\x01\x01\x12\
    \x19\n\x05patch\x18\x05\x20\x01(\x08H\x02R\x05patch\x88\x01\x01\x125\n\
    \x04text\x18\x06\x20\x01(\x0b2\x1c.cyclonedx.v1_3.AttachedTextH\x03R\x04\
    text\x88\x01\x01\x12\x15\n\x03url\x18\x07\x20\x01(\tH\x04R\x03url\x88\
    \x01\x01B\n\n\x08_versionB\x0e\n\x0c_tag_versionB\x08\n\x06_patchB\x07\n\
    \x05_textB\x06\n\x04_url\"\xa9\x01\n\x04Tool\x12\x1b\n\x06vendor\x18\x01\
    \x20\x01(\tH\0R\x06vendor\x88\x01\x01\x12\x17\n\x04name\x18\x02\x20\x01(\
    \tH\x01R\x04name\x88\x01\x01\x12\x1d\n\x07version\x18\x03\x20\x01(\tH\
    \x02R\x07version\x88\x01\x01\x12,\n\x06hashes\x18\x04\x20\x03(\x0b2\x14.\
    cyclonedx.v1_3.HashR\x06hashesB\t\n\x07_vendorB\x07\n\x05_nameB\n\n\x08_\
    version\"C\n\x08Property\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\
    \x12\x19\n\x05value\x18\x02\x20\x01(\tH\0R\x05value\x88\x01\x01B\x08\n\
    \x06_value\"\x8a\x01\n\x0bComposition\x127\n\taggregate\x18\x01\x20\x01(\
    \x0e2\x19.cyclonedx.v1_3.AggregateR\taggregate\x12\x1e\n\nassemblies\x18\
    \x02\x20\x03(\tR\nassemblies\x12\"\n\x0cdependencies\x18\x03\x20\x03(\tR\
    \x0cdependencies\"'\n\x11EvidenceCopyright\x12\x12\n\x04text\x18\x01\x20\
    \x01(\tR\x04text\"\x86\x01\n\x08Evidence\x129\n\x08licenses\x18\x01\x20\
    \x03(\x0b2\x1d.cyclonedx.v1_3.LicenseChoiceR\x08licenses\x12?\n\tcopyrig\
    ht\x18\x02\x20\x03(\x0b2!.cyclonedx.v1_3.EvidenceCopyrightR\tcopyright*\
    \x97\x02\n\x0eClassification\x12\x17\n\x13CLASSIFICATION_NULL\x10\0\x12\
    \x1e\n\x1aCLASSIFICATION_APPLICATION\x10\x01\x12\x1c\n\x18CLASSIFICATION\
    _FRAMEWORK\x10\x02\x12\x1a\n\x16CLASSIFICATION_LIBRARY\x10\x03\x12#\n\
    \x1fCLASSIFICATION_OPERATING_SYSTEM\x10\x04\x12\x19\n\x15CLASSIFICATION_\
    DEVICE\x10\x05\x12\x17\n\x13CLASSIFICATION_FILE\x10\x06\x12\x1c\n\x18CLA\
    SSIFICATION_CONTAINER\x10\x07\x12\x1b\n\x17CLASSIFICATION_FIRMWARE\x10\
    \x08*\x82\x01\n\x08DataFlow\x12\x12\n\x0eDATA_FLOW_NULL\x10\0\x12\x15\n\
    \x11DATA_FLOW_INBOUND\x10\x01\x12\x16\n\x12DATA_FLOW_OUTBOUND\x10\x02\
    \x12\x1c\n\x18DATA_FLOW_BI_DIRECTIONAL\x10\x03\x12\x15\n\x11DATA_FLOW_UN\
    KNOWN\x10\x04*\xd5\x04\n\x15ExternalReferenceType\x12!\n\x1dEXTERNAL_REF\
    ERENCE_TYPE_OTHER\x10\0\x12\x1f\n\x1bEXTERNAL_REFERENCE_TYPE_VCS\x10\x01\
    \x12)\n%EXTERNAL_REFERENCE_TYPE_ISSUE_TRACKER\x10\x02\x12#\n\x1fEXTERNAL\
    _REFERENCE_TYPE_WEBSITE\x10\x03\x12&\n\"EXTERNAL_REFERENCE_TYPE_ADVISORI\
    ES\x10\x04\x12\x1f\n\x1bEXTERNAL_REFERENCE_TYPE_BOM\x10\x05\x12(\n$EXTER\
    NAL_REFERENCE_TYPE_MAILING_LIST\x10\x06\x12\"\n\x1eEXTERNAL_REFERENCE_TY\
    PE_SOCIAL\x10\x07\x12\x20\n\x1cEXTERNAL_REFERENCE_TYPE_CHAT\x10\x08\x12)\
    \n%EXTERNAL_REFERENCE_TYPE_DOCUMENTATION\x10\t\x12#\n\x1fEXTERNAL_REFERE\
    NCE_TYPE_SUPPORT\x10\n\x12(\n$EXTERNAL_REFERENCE_TYPE_DISTRIBUTION\x10\
    \x0b\x12#\n\x1fEXTERNAL_REFERENCE_TYPE_LICENSE\x10\x0c\x12&\n\"EXTERNAL_\
    REFERENCE_TYPE_BUILD_META\x10\r\x12(\n$EXTERNAL_REFERENCE_TYPE_BUILD_SYS\
    TEM\x10\x0e*\xb7\x02\n\x07HashAlg\x12\x11\n\rHASH_ALG_NULL\x10\0\x12\x11\
    \n\rHASH_ALG_MD_5\x10\x01\x12\x12\n\x0eHASH_ALG_SHA_1\x10\x02\x12\x14\n\
    \x10HASH_ALG_SHA_256\x10\x03\x12\x14\n\x10HASH_ALG_SHA_384\x10\x04\x12\
    \x14\n\x10HASH_ALG_SHA_512\x10\x05\x12\x16\n\x12HASH_ALG_SHA_3_256\x10\
    \x06\x12\x16\n\x12HASH_ALG_SHA_3_384\x10\x07\x12\x16\n\x12HASH_ALG_SHA_3\
    _512\x10\x08\x12\x1a\n\x16HASH_ALG_BLAKE_2_B_256\x10\t\x12\x1a\n\x16HASH\
    _ALG_BLAKE_2_B_384\x10\n\x12\x1a\n\x16HASH_ALG_BLAKE_2_B_512\x10\x0b\x12\
    \x14\n\x10HASH_ALG_BLAKE_3\x10\x0c*\x9e\x01\n\x13IssueClassification\x12\
    \x1d\n\x19ISSUE_CLASSIFICATION_NULL\x10\0\x12\x1f\n\x1bISSUE_CLASSIFICAT\
    ION_DEFECT\x10\x01\x12$\n\x20ISSUE_CLASSIFICATION_ENHANCEMENT\x10\x02\
    \x12!\n\x1dISSUE_CLASSIFICATION_SECURITY\x10\x03*\xc3\x01\n\x13PatchClas\
    sification\x12\x1d\n\x19PATCH_CLASSIFICATION_NULL\x10\0\x12#\n\x1fPATCH_\
    CLASSIFICATION_UNOFFICIAL\x10\x01\x12\x1f\n\x1bPATCH_CLASSIFICATION_MONK\
    EY\x10\x02\x12!\n\x1dPATCH_CLASSIFICATION_BACKPORT\x10\x03\x12$\n\x20PAT\
    CH_CLASSIFICATION_CHERRY_PICK\x10\x04*Z\n\x05Scope\x12\x15\n\x11SCOPE_UN\
    SPECIFIED\x10\0\x12\x12\n\x0eSCOPE_REQUIRED\x10\x01\x12\x12\n\x0eSCOPE_O\
    PTIONAL\x10\x02\x12\x12\n\x0eSCOPE_EXCLUDED\x10\x03*\xc7\x01\n\tAggregat\
    e\x12\x1b\n\x17AGGREGATE_NOT_SPECIFIED\x10\0\x12\x16\n\x12AGGREGATE_COMP\
    LETE\x10\x01\x12\x18\n\x14AGGREGATE_INCOMPLETE\x10\x02\x12)\n%AGGREGATE_\
    INCOMPLETE_FIRST_PARTY_ONLY\x10\x03\x12)\n%AGGREGATE_INCOMPLETE_THIRD_PA\
    RTY_ONLY\x10\x04\x12\x15\n\x11AGGREGATE_UNKNOWN\x10\x05b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
